; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -orcc\stm32f1xx_hal_gpio.o --asm_dir=..\ --list_dir=..\ --depend=rcc\stm32f1xx_hal_gpio.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -ID:\RCCv2\RCC\RCC\MDK-ARM\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=rcc\stm32f1xx_hal_gpio.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_gpio.c]
                          THUMB

                          AREA ||i.HAL_GPIO_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_DeInit PROC
;;;364      */
;;;365    void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;366    {
000004  4602              MOV      r2,r0
000006  460b              MOV      r3,r1
;;;367      uint32_t position = 0x00U;
000008  2000              MOVS     r0,#0
;;;368      uint32_t iocurrent = 0x00U;
00000a  2100              MOVS     r1,#0
;;;369      uint32_t tmp = 0x00U;
00000c  2400              MOVS     r4,#0
;;;370      __IO uint32_t *configregister; /* Store the address of CRL or CRH register based on pin number */
;;;371      uint32_t registeroffset = 0U;
00000e  2600              MOVS     r6,#0
;;;372    
;;;373      /* Check the parameters */
;;;374      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;375      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;376    
;;;377      /* Configure the port pins */
;;;378      while ((GPIO_Pin >> position) != 0U)
000010  e07f              B        |L1.274|
                  |L1.18|
;;;379      {
;;;380        /* Get current io position */
;;;381        iocurrent = (GPIO_Pin) & (1U << position);
000012  2701              MOVS     r7,#1
000014  4087              LSLS     r7,r7,r0
000016  ea070103          AND      r1,r7,r3
;;;382    
;;;383        if (iocurrent)
00001a  2900              CMP      r1,#0
00001c  d078              BEQ      |L1.272|
;;;384        {
;;;385          /*------------------------- GPIO Mode Configuration --------------------*/
;;;386          /* Check if the current bit belongs to first half or last half of the pin count number
;;;387           in order to address CRH or CRL register */
;;;388          configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
00001e  29ff              CMP      r1,#0xff
000020  d801              BHI      |L1.38|
000022  4617              MOV      r7,r2
000024  e000              B        |L1.40|
                  |L1.38|
000026  1d17              ADDS     r7,r2,#4
                  |L1.40|
000028  463d              MOV      r5,r7
;;;389          registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2U) : ((position - 8U) << 2U);
00002a  29ff              CMP      r1,#0xff
00002c  d801              BHI      |L1.50|
00002e  0087              LSLS     r7,r0,#2
000030  e002              B        |L1.56|
                  |L1.50|
000032  f1a00708          SUB      r7,r0,#8
000036  00bf              LSLS     r7,r7,#2
                  |L1.56|
000038  463e              MOV      r6,r7
;;;390    
;;;391          /* CRL/CRH default value is floating input(0x04) shifted to correct position */
;;;392          MODIFY_REG(*configregister, ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), GPIO_CRL_CNF0_0 << registeroffset);
00003a  682f              LDR      r7,[r5,#0]
00003c  f04f0c0f          MOV      r12,#0xf
000040  fa0cfc06          LSL      r12,r12,r6
000044  ea27070c          BIC      r7,r7,r12
000048  f04f0c04          MOV      r12,#4
00004c  fa0cfc06          LSL      r12,r12,r6
000050  ea47070c          ORR      r7,r7,r12
000054  602f              STR      r7,[r5,#0]
;;;393    
;;;394          /* ODR default value is 0 */
;;;395          CLEAR_BIT(GPIOx->ODR, iocurrent);
000056  68d7              LDR      r7,[r2,#0xc]
000058  438f              BICS     r7,r7,r1
00005a  60d7              STR      r7,[r2,#0xc]
;;;396    
;;;397          /*------------------------- EXTI Mode Configuration --------------------*/
;;;398          /* Clear the External Interrupt or Event for the current IO */
;;;399    
;;;400          tmp = AFIO->EXTICR[position >> 2U];
00005c  4f30              LDR      r7,|L1.288|
00005e  ea4f0c90          LSR      r12,r0,#2
000062  f857402c          LDR      r4,[r7,r12,LSL #2]
;;;401          tmp &= 0x0FU << (4U * (position & 0x03U));
000066  0787              LSLS     r7,r0,#30
000068  ea4f7c17          LSR      r12,r7,#28
00006c  270f              MOVS     r7,#0xf
00006e  fa07f70c          LSL      r7,r7,r12
000072  403c              ANDS     r4,r4,r7
;;;402          if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
000074  4f2b              LDR      r7,|L1.292|
000076  42ba              CMP      r2,r7
000078  d101              BNE      |L1.126|
00007a  2700              MOVS     r7,#0
00007c  e00f              B        |L1.158|
                  |L1.126|
00007e  4f2a              LDR      r7,|L1.296|
000080  42ba              CMP      r2,r7
000082  d101              BNE      |L1.136|
000084  2701              MOVS     r7,#1
000086  e00a              B        |L1.158|
                  |L1.136|
000088  4f28              LDR      r7,|L1.300|
00008a  42ba              CMP      r2,r7
00008c  d101              BNE      |L1.146|
00008e  2702              MOVS     r7,#2
000090  e005              B        |L1.158|
                  |L1.146|
000092  4f27              LDR      r7,|L1.304|
000094  42ba              CMP      r2,r7
000096  d101              BNE      |L1.156|
000098  2703              MOVS     r7,#3
00009a  e000              B        |L1.158|
                  |L1.156|
00009c  2704              MOVS     r7,#4
                  |L1.158|
00009e  ea4f7c80          LSL      r12,r0,#30
0000a2  ea4f7c1c          LSR      r12,r12,#28
0000a6  fa07f70c          LSL      r7,r7,r12
0000aa  42a7              CMP      r7,r4
0000ac  d130              BNE      |L1.272|
;;;403          {
;;;404            tmp = 0x0FU << (4U * (position & 0x03U));
0000ae  0787              LSLS     r7,r0,#30
0000b0  ea4f7c17          LSR      r12,r7,#28
0000b4  270f              MOVS     r7,#0xf
0000b6  fa07f40c          LSL      r4,r7,r12
;;;405            CLEAR_BIT(AFIO->EXTICR[position >> 2U], tmp);
0000ba  4f19              LDR      r7,|L1.288|
0000bc  ea4f0c90          LSR      r12,r0,#2
0000c0  f857702c          LDR      r7,[r7,r12,LSL #2]
0000c4  43a7              BICS     r7,r7,r4
0000c6  f8dfc058          LDR      r12,|L1.288|
0000ca  ea4f0890          LSR      r8,r0,#2
0000ce  f84c7028          STR      r7,[r12,r8,LSL #2]
;;;406    
;;;407            /* Clear EXTI line configuration */
;;;408            CLEAR_BIT(EXTI->IMR, (uint32_t)iocurrent);
0000d2  4f18              LDR      r7,|L1.308|
0000d4  683f              LDR      r7,[r7,#0]
0000d6  438f              BICS     r7,r7,r1
0000d8  f8dfc058          LDR      r12,|L1.308|
0000dc  f8cc7000          STR      r7,[r12,#0]
;;;409            CLEAR_BIT(EXTI->EMR, (uint32_t)iocurrent);
0000e0  f10c0704          ADD      r7,r12,#4
0000e4  683f              LDR      r7,[r7,#0]
0000e6  438f              BICS     r7,r7,r1
0000e8  f10c0c04          ADD      r12,r12,#4
0000ec  f8cc7000          STR      r7,[r12,#0]
;;;410    
;;;411            /* Clear Rising Falling edge configuration */
;;;412            CLEAR_BIT(EXTI->RTSR, (uint32_t)iocurrent);
0000f0  f10c0704          ADD      r7,r12,#4
0000f4  683f              LDR      r7,[r7,#0]
0000f6  438f              BICS     r7,r7,r1
0000f8  f10c0c04          ADD      r12,r12,#4
0000fc  f8cc7000          STR      r7,[r12,#0]
;;;413            CLEAR_BIT(EXTI->FTSR, (uint32_t)iocurrent);
000100  f10c0704          ADD      r7,r12,#4
000104  683f              LDR      r7,[r7,#0]
000106  438f              BICS     r7,r7,r1
000108  f10c0c04          ADD      r12,r12,#4
00010c  f8cc7000          STR      r7,[r12,#0]
                  |L1.272|
;;;414          }
;;;415        }
;;;416    
;;;417        position++;
000110  1c40              ADDS     r0,r0,#1
                  |L1.274|
000112  fa23f700          LSR      r7,r3,r0              ;378
000116  2f00              CMP      r7,#0                 ;378
000118  f47faf7b          BNE      |L1.18|
;;;418      }
;;;419    }
00011c  e8bd81f0          POP      {r4-r8,pc}
;;;420    
                          ENDP

                  |L1.288|
                          DCD      0x40010008
                  |L1.292|
                          DCD      0x40010800
                  |L1.296|
                          DCD      0x40010c00
                  |L1.300|
                          DCD      0x40011000
                  |L1.304|
                          DCD      0x40011400
                  |L1.308|
                          DCD      0x40010400

                          AREA ||i.HAL_GPIO_EXTI_Callback||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_EXTI_Callback PROC
;;;568      */
;;;569    __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
000000  4770              BX       lr
;;;570    {
;;;571      /* Prevent unused argument(s) compilation warning */
;;;572      UNUSED(GPIO_Pin);
;;;573      /* NOTE: This function Should not be modified, when the callback is needed,
;;;574               the HAL_GPIO_EXTI_Callback could be implemented in the user file
;;;575       */
;;;576    }
;;;577    
                          ENDP


                          AREA ||i.HAL_GPIO_EXTI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_EXTI_IRQHandler PROC
;;;553      */
;;;554    void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
000000  b510              PUSH     {r4,lr}
;;;555    {
000002  4604              MOV      r4,r0
;;;556      /* EXTI line interrupt detected */
;;;557      if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
000004  4804              LDR      r0,|L3.24|
000006  6800              LDR      r0,[r0,#0]
000008  4020              ANDS     r0,r0,r4
00000a  b120              CBZ      r0,|L3.22|
;;;558      {
;;;559        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
00000c  4802              LDR      r0,|L3.24|
00000e  6004              STR      r4,[r0,#0]
;;;560        HAL_GPIO_EXTI_Callback(GPIO_Pin);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       HAL_GPIO_EXTI_Callback
                  |L3.22|
;;;561      }
;;;562    }
000016  bd10              POP      {r4,pc}
;;;563    
                          ENDP

                  |L3.24|
                          DCD      0x40010414

                          AREA ||i.HAL_GPIO_Init||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_Init PROC
;;;193      */
;;;194    void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
000000  e92d47f8          PUSH     {r3-r10,lr}
;;;195    {
000004  4603              MOV      r3,r0
;;;196      uint32_t position;
;;;197      uint32_t ioposition = 0x00U;
000006  2400              MOVS     r4,#0
;;;198      uint32_t iocurrent = 0x00U;
000008  2000              MOVS     r0,#0
;;;199      uint32_t temp = 0x00U;
00000a  2500              MOVS     r5,#0
;;;200      uint32_t config = 0x00U;
00000c  4684              MOV      r12,r0
;;;201      __IO uint32_t *configregister; /* Store the address of CRL or CRH register based on pin number */
;;;202      uint32_t registeroffset = 0U; /* offset used during computation of CNF and MODE bits placement inside CRL or CRH register */
00000e  2700              MOVS     r7,#0
;;;203    
;;;204      /* Check the parameters */
;;;205      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;206      assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
;;;207      assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
;;;208    
;;;209      /* Configure the port pins */
;;;210      for (position = 0U; position < GPIO_NUMBER; position++)
000010  2200              MOVS     r2,#0
000012  e16e              B        |L4.754|
                  |L4.20|
;;;211      {
;;;212        /* Get the IO position */
;;;213        ioposition = (0x01U << position);
000014  f04f0801          MOV      r8,#1
000018  fa08f402          LSL      r4,r8,r2
;;;214    
;;;215        /* Get the current IO position */
;;;216        iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
00001c  f8d18000          LDR      r8,[r1,#0]
000020  ea080004          AND      r0,r8,r4
;;;217    
;;;218        if (iocurrent == ioposition)
000024  42a0              CMP      r0,r4
000026  d17d              BNE      |L4.292|
;;;219        {
;;;220          /* Check the Alternate function parameters */
;;;221          assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
;;;222    
;;;223          /* Based on the required mode, filling config variable with MODEy[1:0] and CNFy[3:2] corresponding bits */
;;;224          switch (GPIO_Init->Mode)
000028  f8dfa2d0          LDR      r10,|L4.764|
00002c  f8d18004          LDR      r8,[r1,#4]
000030  eba8090a          SUB      r9,r8,r10
000034  45d0              CMP      r8,r10
000036  d03a              BEQ      |L4.174|
000038  dc14              BGT      |L4.100|
00003a  f1b80f03          CMP      r8,#3
00003e  d050              BEQ      |L4.226|
000040  dc09              BGT      |L4.86|
000042  f1b80f00          CMP      r8,#0
000046  d031              BEQ      |L4.172|
000048  f1b80f01          CMP      r8,#1
00004c  d01c              BEQ      |L4.136|
00004e  f1b80f02          CMP      r8,#2
000052  d149              BNE      |L4.232|
000054  e020              B        |L4.152|
                  |L4.86|
000056  f1b80f11          CMP      r8,#0x11
00005a  d018              BEQ      |L4.142|
00005c  f1b80f12          CMP      r8,#0x12
000060  d142              BNE      |L4.232|
000062  e01e              B        |L4.162|
                  |L4.100|
000064  f5b91f88          CMP      r9,#0x110000
000068  d025              BEQ      |L4.182|
00006a  dc06              BGT      |L4.122|
00006c  f5b93f80          CMP      r9,#0x10000
000070  d020              BEQ      |L4.180|
000072  f5b91f80          CMP      r9,#0x100000
000076  d137              BNE      |L4.232|
000078  e01a              B        |L4.176|
                  |L4.122|
00007a  f5b91f00          CMP      r9,#0x200000
00007e  d018              BEQ      |L4.178|
000080  f5b91f04          CMP      r9,#0x210000
000084  d130              BNE      |L4.232|
000086  e017              B        |L4.184|
                  |L4.136|
;;;225          {
;;;226            /* If we are configuring the pin in OUTPUT push-pull mode */
;;;227            case GPIO_MODE_OUTPUT_PP:
;;;228              /* Check the GPIO speed parameter */
;;;229              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;230              config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
000088  f8d1c00c          LDR      r12,[r1,#0xc]
;;;231              break;
00008c  e02d              B        |L4.234|
                  |L4.142|
;;;232    
;;;233            /* If we are configuring the pin in OUTPUT open-drain mode */
;;;234            case GPIO_MODE_OUTPUT_OD:
;;;235              /* Check the GPIO speed parameter */
;;;236              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;237              config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
00008e  f8d1800c          LDR      r8,[r1,#0xc]
000092  f1080c04          ADD      r12,r8,#4
;;;238              break;
000096  e028              B        |L4.234|
                  |L4.152|
;;;239    
;;;240            /* If we are configuring the pin in ALTERNATE FUNCTION push-pull mode */
;;;241            case GPIO_MODE_AF_PP:
;;;242              /* Check the GPIO speed parameter */
;;;243              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;244              config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
000098  f8d1800c          LDR      r8,[r1,#0xc]
00009c  f1080c08          ADD      r12,r8,#8
;;;245              break;
0000a0  e023              B        |L4.234|
                  |L4.162|
;;;246    
;;;247            /* If we are configuring the pin in ALTERNATE FUNCTION open-drain mode */
;;;248            case GPIO_MODE_AF_OD:
;;;249              /* Check the GPIO speed parameter */
;;;250              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;251              config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
0000a2  f8d1800c          LDR      r8,[r1,#0xc]
0000a6  f1080c0c          ADD      r12,r8,#0xc
;;;252              break;
0000aa  e01e              B        |L4.234|
                  |L4.172|
;;;253    
;;;254            /* If we are configuring the pin in INPUT (also applicable to EVENT and IT mode) */
;;;255            case GPIO_MODE_INPUT:
;;;256            case GPIO_MODE_IT_RISING:
0000ac  bf00              NOP      
                  |L4.174|
;;;257            case GPIO_MODE_IT_FALLING:
0000ae  bf00              NOP      
                  |L4.176|
;;;258            case GPIO_MODE_IT_RISING_FALLING:
0000b0  bf00              NOP      
                  |L4.178|
;;;259            case GPIO_MODE_EVT_RISING:
0000b2  bf00              NOP      
                  |L4.180|
;;;260            case GPIO_MODE_EVT_FALLING:
0000b4  bf00              NOP      
                  |L4.182|
;;;261            case GPIO_MODE_EVT_RISING_FALLING:
0000b6  bf00              NOP      
                  |L4.184|
;;;262              /* Check the GPIO pull parameter */
;;;263              assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
;;;264              if (GPIO_Init->Pull == GPIO_NOPULL)
0000b8  f8d18008          LDR      r8,[r1,#8]
0000bc  f1b80f00          CMP      r8,#0
0000c0  d102              BNE      |L4.200|
;;;265              {
;;;266                config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
0000c2  f04f0c04          MOV      r12,#4
0000c6  e00b              B        |L4.224|
                  |L4.200|
;;;267              }
;;;268              else if (GPIO_Init->Pull == GPIO_PULLUP)
0000c8  f8d18008          LDR      r8,[r1,#8]
0000cc  f1b80f01          CMP      r8,#1
0000d0  d103              BNE      |L4.218|
;;;269              {
;;;270                config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
0000d2  f04f0c08          MOV      r12,#8
;;;271    
;;;272                /* Set the corresponding ODR bit */
;;;273                GPIOx->BSRR = ioposition;
0000d6  611c              STR      r4,[r3,#0x10]
0000d8  e002              B        |L4.224|
                  |L4.218|
;;;274              }
;;;275              else /* GPIO_PULLDOWN */
;;;276              {
;;;277                config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
0000da  f04f0c08          MOV      r12,#8
;;;278    
;;;279                /* Reset the corresponding ODR bit */
;;;280                GPIOx->BRR = ioposition;
0000de  615c              STR      r4,[r3,#0x14]
                  |L4.224|
;;;281              }
;;;282              break;
0000e0  e003              B        |L4.234|
                  |L4.226|
;;;283    
;;;284            /* If we are configuring the pin in INPUT analog mode */
;;;285            case GPIO_MODE_ANALOG:
;;;286              config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;
0000e2  f04f0c00          MOV      r12,#0
;;;287              break;
0000e6  e000              B        |L4.234|
                  |L4.232|
;;;288    
;;;289            /* Parameters are checked with assert_param */
;;;290            default:
;;;291              break;
0000e8  bf00              NOP      
                  |L4.234|
0000ea  bf00              NOP                            ;231
;;;292          }
;;;293    
;;;294          /* Check if the current bit belongs to first half or last half of the pin count number
;;;295           in order to address CRH or CRL register*/
;;;296          configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
0000ec  28ff              CMP      r0,#0xff
0000ee  d801              BHI      |L4.244|
0000f0  4698              MOV      r8,r3
0000f2  e001              B        |L4.248|
                  |L4.244|
0000f4  f1030804          ADD      r8,r3,#4
                  |L4.248|
0000f8  4646              MOV      r6,r8
;;;297          registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2U) : ((position - 8U) << 2U);
0000fa  28ff              CMP      r0,#0xff
0000fc  d802              BHI      |L4.260|
0000fe  ea4f0882          LSL      r8,r2,#2
000102  e003              B        |L4.268|
                  |L4.260|
000104  f1a20808          SUB      r8,r2,#8
000108  ea4f0888          LSL      r8,r8,#2
                  |L4.268|
00010c  4647              MOV      r7,r8
;;;298    
;;;299          /* Apply the new configuration of the pin to the register */
;;;300          MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
00010e  f8d68000          LDR      r8,[r6,#0]
000112  f04f090f          MOV      r9,#0xf
000116  fa09f907          LSL      r9,r9,r7
00011a  ea280809          BIC      r8,r8,r9
00011e  fa0cf907          LSL      r9,r12,r7
000122  e000              B        |L4.294|
                  |L4.292|
000124  e088              B        |L4.568|
                  |L4.294|
000126  ea480809          ORR      r8,r8,r9
00012a  f8c68000          STR      r8,[r6,#0]
;;;301    
;;;302          /*--------------------- EXTI Mode Configuration ------------------------*/
;;;303          /* Configure the External Interrupt or event for the current IO */
;;;304          if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
00012e  f8d18004          LDR      r8,[r1,#4]
000132  f0085880          AND      r8,r8,#0x10000000
000136  f1b85f80          CMP      r8,#0x10000000
00013a  d17d              BNE      |L4.568|
;;;305          {
;;;306            /* Enable AFIO Clock */
;;;307            __HAL_RCC_AFIO_CLK_ENABLE();
00013c  bf00              NOP      
00013e  f8df81c0          LDR      r8,|L4.768|
000142  f8d88018          LDR      r8,[r8,#0x18]
000146  f0480801          ORR      r8,r8,#1
00014a  f8df91b4          LDR      r9,|L4.768|
00014e  f8c98018          STR      r8,[r9,#0x18]
000152  46c8              MOV      r8,r9
000154  f8d88018          LDR      r8,[r8,#0x18]
000158  f0080801          AND      r8,r8,#1
00015c  f8cd8000          STR      r8,[sp,#0]
000160  bf00              NOP      
000162  bf00              NOP      
;;;308            temp = AFIO->EXTICR[position >> 2U];
000164  ea4f38b9          ROR      r8,r9,#14
000168  ea4f0992          LSR      r9,r2,#2
00016c  f8585029          LDR      r5,[r8,r9,LSL #2]
;;;309            CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
000170  ea4f7882          LSL      r8,r2,#30
000174  ea4f7918          LSR      r9,r8,#28
000178  f04f080f          MOV      r8,#0xf
00017c  fa08f809          LSL      r8,r8,r9
000180  ea250508          BIC      r5,r5,r8
;;;310            SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
000184  f8df817c          LDR      r8,|L4.772|
000188  4543              CMP      r3,r8
00018a  d102              BNE      |L4.402|
00018c  f04f0800          MOV      r8,#0
000190  e016              B        |L4.448|
                  |L4.402|
000192  f8df8174          LDR      r8,|L4.776|
000196  4543              CMP      r3,r8
000198  d102              BNE      |L4.416|
00019a  f04f0801          MOV      r8,#1
00019e  e00f              B        |L4.448|
                  |L4.416|
0001a0  f8df8168          LDR      r8,|L4.780|
0001a4  4543              CMP      r3,r8
0001a6  d102              BNE      |L4.430|
0001a8  f04f0802          MOV      r8,#2
0001ac  e008              B        |L4.448|
                  |L4.430|
0001ae  f8df8160          LDR      r8,|L4.784|
0001b2  4543              CMP      r3,r8
0001b4  d102              BNE      |L4.444|
0001b6  f04f0803          MOV      r8,#3
0001ba  e001              B        |L4.448|
                  |L4.444|
0001bc  f04f0804          MOV      r8,#4
                  |L4.448|
0001c0  ea4f7982          LSL      r9,r2,#30
0001c4  ea4f7919          LSR      r9,r9,#28
0001c8  fa08f809          LSL      r8,r8,r9
0001cc  ea480505          ORR      r5,r8,r5
;;;311            AFIO->EXTICR[position >> 2U] = temp;
0001d0  f8df8140          LDR      r8,|L4.788|
0001d4  ea4f0992          LSR      r9,r2,#2
0001d8  f8485029          STR      r5,[r8,r9,LSL #2]
;;;312    
;;;313    
;;;314            /* Configure the interrupt mask */
;;;315            if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
0001dc  f8d18004          LDR      r8,[r1,#4]
0001e0  f4083880          AND      r8,r8,#0x10000
0001e4  f5b83f80          CMP      r8,#0x10000
0001e8  d10a              BNE      |L4.512|
;;;316            {
;;;317              SET_BIT(EXTI->IMR, iocurrent);
0001ea  f8df812c          LDR      r8,|L4.792|
0001ee  f8d88000          LDR      r8,[r8,#0]
0001f2  ea480800          ORR      r8,r8,r0
0001f6  f8df9120          LDR      r9,|L4.792|
0001fa  f8c98000          STR      r8,[r9,#0]
0001fe  e009              B        |L4.532|
                  |L4.512|
;;;318            }
;;;319            else
;;;320            {
;;;321              CLEAR_BIT(EXTI->IMR, iocurrent);
000200  f8df8114          LDR      r8,|L4.792|
000204  f8d88000          LDR      r8,[r8,#0]
000208  ea280800          BIC      r8,r8,r0
00020c  f8df9108          LDR      r9,|L4.792|
000210  f8c98000          STR      r8,[r9,#0]
                  |L4.532|
;;;322            }
;;;323    
;;;324            /* Configure the event mask */
;;;325            if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
000214  f8d18004          LDR      r8,[r1,#4]
000218  f4083800          AND      r8,r8,#0x20000
00021c  f5b83f00          CMP      r8,#0x20000
000220  d110              BNE      |L4.580|
;;;326            {
;;;327              SET_BIT(EXTI->EMR, iocurrent);
000222  f8df80f4          LDR      r8,|L4.792|
000226  f1080804          ADD      r8,r8,#4
00022a  f8d88000          LDR      r8,[r8,#0]
00022e  ea480800          ORR      r8,r8,r0
000232  f8df90e4          LDR      r9,|L4.792|
000236  e000              B        |L4.570|
                  |L4.568|
000238  e05a              B        |L4.752|
                  |L4.570|
00023a  f1090904          ADD      r9,r9,#4
00023e  f8c98000          STR      r8,[r9,#0]
000242  e00d              B        |L4.608|
                  |L4.580|
;;;328            }
;;;329            else
;;;330            {
;;;331              CLEAR_BIT(EXTI->EMR, iocurrent);
000244  f8df80d0          LDR      r8,|L4.792|
000248  f1080804          ADD      r8,r8,#4
00024c  f8d88000          LDR      r8,[r8,#0]
000250  ea280800          BIC      r8,r8,r0
000254  f8df90c0          LDR      r9,|L4.792|
000258  f1090904          ADD      r9,r9,#4
00025c  f8c98000          STR      r8,[r9,#0]
                  |L4.608|
;;;332            }
;;;333    
;;;334            /* Enable or disable the rising trigger */
;;;335            if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
000260  f8d18004          LDR      r8,[r1,#4]
000264  f4081880          AND      r8,r8,#0x100000
000268  f5b81f80          CMP      r8,#0x100000
00026c  d10e              BNE      |L4.652|
;;;336            {
;;;337              SET_BIT(EXTI->RTSR, iocurrent);
00026e  f8df80a8          LDR      r8,|L4.792|
000272  f1080808          ADD      r8,r8,#8
000276  f8d88000          LDR      r8,[r8,#0]
00027a  ea480800          ORR      r8,r8,r0
00027e  f8df9098          LDR      r9,|L4.792|
000282  f1090908          ADD      r9,r9,#8
000286  f8c98000          STR      r8,[r9,#0]
00028a  e00d              B        |L4.680|
                  |L4.652|
;;;338            }
;;;339            else
;;;340            {
;;;341              CLEAR_BIT(EXTI->RTSR, iocurrent);
00028c  f8df8088          LDR      r8,|L4.792|
000290  f1080808          ADD      r8,r8,#8
000294  f8d88000          LDR      r8,[r8,#0]
000298  ea280800          BIC      r8,r8,r0
00029c  f8df9078          LDR      r9,|L4.792|
0002a0  f1090908          ADD      r9,r9,#8
0002a4  f8c98000          STR      r8,[r9,#0]
                  |L4.680|
;;;342            }
;;;343    
;;;344            /* Enable or disable the falling trigger */
;;;345            if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
0002a8  f8d18004          LDR      r8,[r1,#4]
0002ac  f4081800          AND      r8,r8,#0x200000
0002b0  f5b81f00          CMP      r8,#0x200000
0002b4  d10e              BNE      |L4.724|
;;;346            {
;;;347              SET_BIT(EXTI->FTSR, iocurrent);
0002b6  f8df8060          LDR      r8,|L4.792|
0002ba  f108080c          ADD      r8,r8,#0xc
0002be  f8d88000          LDR      r8,[r8,#0]
0002c2  ea480800          ORR      r8,r8,r0
0002c6  f8df9050          LDR      r9,|L4.792|
0002ca  f109090c          ADD      r9,r9,#0xc
0002ce  f8c98000          STR      r8,[r9,#0]
0002d2  e00d              B        |L4.752|
                  |L4.724|
;;;348            }
;;;349            else
;;;350            {
;;;351              CLEAR_BIT(EXTI->FTSR, iocurrent);
0002d4  f8df8040          LDR      r8,|L4.792|
0002d8  f108080c          ADD      r8,r8,#0xc
0002dc  f8d88000          LDR      r8,[r8,#0]
0002e0  ea280800          BIC      r8,r8,r0
0002e4  f8df9030          LDR      r9,|L4.792|
0002e8  f109090c          ADD      r9,r9,#0xc
0002ec  f8c98000          STR      r8,[r9,#0]
                  |L4.752|
0002f0  1c52              ADDS     r2,r2,#1              ;210
                  |L4.754|
0002f2  2a10              CMP      r2,#0x10              ;210
0002f4  f4ffae8e          BCC      |L4.20|
;;;352            }
;;;353          }
;;;354        }
;;;355      }
;;;356    }
0002f8  e8bd87f8          POP      {r3-r10,pc}
;;;357    
                          ENDP

                  |L4.764|
                          DCD      0x10110000
                  |L4.768|
                          DCD      0x40021000
                  |L4.772|
                          DCD      0x40010800
                  |L4.776|
                          DCD      0x40010c00
                  |L4.780|
                          DCD      0x40011000
                  |L4.784|
                          DCD      0x40011400
                  |L4.788|
                          DCD      0x40010008
                  |L4.792|
                          DCD      0x40010400

                          AREA ||i.HAL_GPIO_LockPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_LockPin PROC
;;;519    */
;;;520    HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
000000  b508              PUSH     {r3,lr}
;;;521    {
000002  4602              MOV      r2,r0
;;;522      __IO uint32_t tmp = GPIO_LCKR_LCKK;
000004  f44f3080          MOV      r0,#0x10000
000008  9000              STR      r0,[sp,#0]
;;;523    
;;;524      /* Check the parameters */
;;;525      assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
;;;526      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;527    
;;;528      /* Apply lock key write sequence */
;;;529      SET_BIT(tmp, GPIO_Pin);
00000a  9800              LDR      r0,[sp,#0]
00000c  4308              ORRS     r0,r0,r1
00000e  9000              STR      r0,[sp,#0]
;;;530      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;531      GPIOx->LCKR = tmp;
000010  9800              LDR      r0,[sp,#0]
000012  6190              STR      r0,[r2,#0x18]
;;;532      /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
;;;533      GPIOx->LCKR = GPIO_Pin;
000014  6191              STR      r1,[r2,#0x18]
;;;534      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;535      GPIOx->LCKR = tmp;
000016  9800              LDR      r0,[sp,#0]
000018  6190              STR      r0,[r2,#0x18]
;;;536      /* Read LCKK bit*/
;;;537      tmp = GPIOx->LCKR;
00001a  6990              LDR      r0,[r2,#0x18]
00001c  9000              STR      r0,[sp,#0]
;;;538    
;;;539      if ((uint32_t)(GPIOx->LCKR & GPIO_LCKR_LCKK))
00001e  6990              LDR      r0,[r2,#0x18]
000020  f4003080          AND      r0,r0,#0x10000
000024  b108              CBZ      r0,|L5.42|
;;;540      {
;;;541        return HAL_OK;
000026  2000              MOVS     r0,#0
                  |L5.40|
;;;542      }
;;;543      else
;;;544      {
;;;545        return HAL_ERROR;
;;;546      }
;;;547    }
000028  bd08              POP      {r3,pc}
                  |L5.42|
00002a  2001              MOVS     r0,#1                 ;545
00002c  e7fc              B        |L5.40|
;;;548    
                          ENDP


                          AREA ||i.HAL_GPIO_ReadPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_ReadPin PROC
;;;445      */
;;;446    GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
000000  4602              MOV      r2,r0
;;;447    {
;;;448      GPIO_PinState bitstatus;
;;;449    
;;;450      /* Check the parameters */
;;;451      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;452    
;;;453      if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
000002  6893              LDR      r3,[r2,#8]
000004  400b              ANDS     r3,r3,r1
000006  b10b              CBZ      r3,|L6.12|
;;;454      {
;;;455        bitstatus = GPIO_PIN_SET;
000008  2001              MOVS     r0,#1
00000a  e000              B        |L6.14|
                  |L6.12|
;;;456      }
;;;457      else
;;;458      { 
;;;459        bitstatus = GPIO_PIN_RESET;
00000c  2000              MOVS     r0,#0
                  |L6.14|
;;;460      }
;;;461      return bitstatus;
;;;462    }
00000e  4770              BX       lr
;;;463    
                          ENDP


                          AREA ||i.HAL_GPIO_TogglePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_TogglePin PROC
;;;501      */
;;;502    void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
000000  68c2              LDR      r2,[r0,#0xc]
;;;503    {
;;;504      /* Check the parameters */
;;;505      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;506    
;;;507      GPIOx->ODR ^= GPIO_Pin;
000002  404a              EORS     r2,r2,r1
000004  60c2              STR      r2,[r0,#0xc]
;;;508    }
000006  4770              BX       lr
;;;509    
                          ENDP


                          AREA ||i.HAL_GPIO_WritePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_WritePin PROC
;;;479      */
;;;480    void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
000000  b10a              CBZ      r2,|L8.6|
;;;481    {
;;;482      /* Check the parameters */
;;;483      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;484      assert_param(IS_GPIO_PIN_ACTION(PinState));
;;;485    
;;;486      if (PinState != GPIO_PIN_RESET)
;;;487      {
;;;488        GPIOx->BSRR = GPIO_Pin;
000002  6101              STR      r1,[r0,#0x10]
000004  e001              B        |L8.10|
                  |L8.6|
;;;489      }
;;;490      else
;;;491      {
;;;492        GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
000006  040b              LSLS     r3,r1,#16
000008  6103              STR      r3,[r0,#0x10]
                  |L8.10|
;;;493      }
;;;494    }
00000a  4770              BX       lr
;;;495    
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_gpio_c_ea787061____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___20_stm32f1xx_hal_gpio_c_ea787061____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_gpio_c_ea787061____REVSH|
#line 402
|__asm___20_stm32f1xx_hal_gpio_c_ea787061____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_gpio_c_ea787061____RRX|
#line 587
|__asm___20_stm32f1xx_hal_gpio_c_ea787061____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
