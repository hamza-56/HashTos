; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -orcc\stm32f1xx_hal.o --asm_dir=..\ --list_dir=..\ --depend=rcc\stm32f1xx_hal.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -ID:\RCCv2\RCC\RCC\MDK-ARM\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=rcc\stm32f1xx_hal.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal.c]
                          THUMB

                          AREA ||i.HAL_DBGMCU_DisableDBGSleepMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGSleepMode PROC
;;;482      */
;;;483    void HAL_DBGMCU_DisableDBGSleepMode(void)
000000  4803              LDR      r0,|L1.16|
;;;484    {
;;;485      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
000002  6840              LDR      r0,[r0,#4]
000004  f0200001          BIC      r0,r0,#1
000008  4901              LDR      r1,|L1.16|
00000a  6048              STR      r0,[r1,#4]
;;;486    }
00000c  4770              BX       lr
;;;487    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_DisableDBGStandbyMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGStandbyMode PROC
;;;560      */
;;;561    void HAL_DBGMCU_DisableDBGStandbyMode(void)
000000  4803              LDR      r0,|L2.16|
;;;562    {
;;;563      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
000002  6840              LDR      r0,[r0,#4]
000004  f0200004          BIC      r0,r0,#4
000008  4901              LDR      r1,|L2.16|
00000a  6048              STR      r0,[r1,#4]
;;;564    }
00000c  4770              BX       lr
;;;565    
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_DisableDBGStopMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGStopMode PROC
;;;528      */
;;;529    void HAL_DBGMCU_DisableDBGStopMode(void)
000000  4803              LDR      r0,|L3.16|
;;;530    {
;;;531      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
000002  6840              LDR      r0,[r0,#4]
000004  f0200002          BIC      r0,r0,#2
000008  4901              LDR      r1,|L3.16|
00000a  6048              STR      r0,[r1,#4]
;;;532    }
00000c  4770              BX       lr
;;;533    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGSleepMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGSleepMode PROC
;;;466      */
;;;467    void HAL_DBGMCU_EnableDBGSleepMode(void)
000000  4803              LDR      r0,|L4.16|
;;;468    {
;;;469      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
000002  6840              LDR      r0,[r0,#4]
000004  f0400001          ORR      r0,r0,#1
000008  4901              LDR      r1,|L4.16|
00000a  6048              STR      r0,[r1,#4]
;;;470    }
00000c  4770              BX       lr
;;;471    
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGStandbyMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGStandbyMode PROC
;;;544      */
;;;545    void HAL_DBGMCU_EnableDBGStandbyMode(void)
000000  4803              LDR      r0,|L5.16|
;;;546    {
;;;547      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
000002  6840              LDR      r0,[r0,#4]
000004  f0400004          ORR      r0,r0,#4
000008  4901              LDR      r1,|L5.16|
00000a  6048              STR      r0,[r1,#4]
;;;548    }
00000c  4770              BX       lr
;;;549    
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGStopMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGStopMode PROC
;;;512      */
;;;513    void HAL_DBGMCU_EnableDBGStopMode(void)
000000  4803              LDR      r0,|L6.16|
;;;514    {
;;;515      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
000002  6840              LDR      r0,[r0,#4]
000004  f0400002          ORR      r0,r0,#2
000008  4901              LDR      r1,|L6.16|
00000a  6048              STR      r0,[r1,#4]
;;;516    }
00000c  4770              BX       lr
;;;517    
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
                          DCD      0xe0042000

                          AREA ||i.HAL_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_DeInit PROC
;;;190      */
;;;191    HAL_StatusTypeDef HAL_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;192    {
;;;193      /* Reset of all peripherals */
;;;194      __HAL_RCC_APB1_FORCE_RESET();
000002  f04f30ff          MOV      r0,#0xffffffff
000006  4906              LDR      r1,|L7.32|
000008  60c8              STR      r0,[r1,#0xc]
;;;195      __HAL_RCC_APB1_RELEASE_RESET();
00000a  2000              MOVS     r0,#0
00000c  6108              STR      r0,[r1,#0x10]
;;;196    
;;;197      __HAL_RCC_APB2_FORCE_RESET();
00000e  1e40              SUBS     r0,r0,#1
000010  60c8              STR      r0,[r1,#0xc]
;;;198      __HAL_RCC_APB2_RELEASE_RESET();
000012  2000              MOVS     r0,#0
000014  60c8              STR      r0,[r1,#0xc]
;;;199    
;;;200    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;201      __HAL_RCC_AHB_FORCE_RESET();
;;;202      __HAL_RCC_AHB_RELEASE_RESET();
;;;203    #endif
;;;204    
;;;205      /* De-Init the low level hardware */
;;;206      HAL_MspDeInit();
000016  f7fffffe          BL       HAL_MspDeInit
;;;207    
;;;208      /* Return function status */
;;;209      return HAL_OK;
00001a  2000              MOVS     r0,#0
;;;210    }
00001c  bd10              POP      {r4,pc}
;;;211    
                          ENDP

00001e  0000              DCW      0x0000
                  |L7.32|
                          DCD      0x40021000

                          AREA ||i.HAL_Delay||, CODE, READONLY, ALIGN=2

                  HAL_Delay PROC
;;;373      */
;;;374    __weak void HAL_Delay(uint32_t Delay)
000000  b570              PUSH     {r4-r6,lr}
;;;375    {
000002  4604              MOV      r4,r0
;;;376      uint32_t tickstart = HAL_GetTick();
000004  f7fffffe          BL       HAL_GetTick
000008  4606              MOV      r6,r0
;;;377      uint32_t wait = Delay;
00000a  4625              MOV      r5,r4
;;;378    
;;;379      /* Add a freq to guarantee minimum wait */
;;;380      if (wait < HAL_MAX_DELAY)
00000c  1c68              ADDS     r0,r5,#1
00000e  b110              CBZ      r0,|L8.22|
;;;381      {
;;;382        wait += (uint32_t)(uwTickFreq);
000010  4804              LDR      r0,|L8.36|
000012  7800              LDRB     r0,[r0,#0]  ; uwTickFreq
000014  4405              ADD      r5,r5,r0
                  |L8.22|
;;;383      }
;;;384    
;;;385      while ((HAL_GetTick() - tickstart) < wait)
000016  bf00              NOP      
                  |L8.24|
000018  f7fffffe          BL       HAL_GetTick
00001c  1b80              SUBS     r0,r0,r6
00001e  42a8              CMP      r0,r5
000020  d3fa              BCC      |L8.24|
;;;386      {
;;;387      }
;;;388    }
000022  bd70              POP      {r4-r6,pc}
;;;389    
                          ENDP

                  |L8.36|
                          DCD      uwTickFreq

                          AREA ||i.HAL_GetDEVID||, CODE, READONLY, ALIGN=2

                  HAL_GetDEVID PROC
;;;457      */
;;;458    uint32_t HAL_GetDEVID(void)
000000  4802              LDR      r0,|L9.12|
;;;459    {
;;;460      return ((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
000002  6800              LDR      r0,[r0,#0]
000004  f3c0000b          UBFX     r0,r0,#0,#12
;;;461    }
000008  4770              BX       lr
;;;462    
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_GetHalVersion||, CODE, READONLY, ALIGN=2

                  HAL_GetHalVersion PROC
;;;425      */
;;;426    uint32_t HAL_GetHalVersion(void)
000000  4800              LDR      r0,|L10.4|
;;;427    {
;;;428      return __STM32F1xx_HAL_VERSION;
;;;429    }
000002  4770              BX       lr
;;;430    
                          ENDP

                  |L10.4|
                          DCD      0x01010200

                          AREA ||i.HAL_GetREVID||, CODE, READONLY, ALIGN=2

                  HAL_GetREVID PROC
;;;441      */
;;;442    uint32_t HAL_GetREVID(void)
000000  4801              LDR      r0,|L11.8|
;;;443    {
;;;444      return ((DBGMCU->IDCODE) >> DBGMCU_IDCODE_REV_ID_Pos);
000002  6800              LDR      r0,[r0,#0]
000004  0c00              LSRS     r0,r0,#16
;;;445    }
000006  4770              BX       lr
;;;446    
                          ENDP

                  |L11.8|
                          DCD      0xe0042000

                          AREA ||i.HAL_GetTick||, CODE, READONLY, ALIGN=2

                  HAL_GetTick PROC
;;;319      */
;;;320    __weak uint32_t HAL_GetTick(void)
000000  4801              LDR      r0,|L12.8|
;;;321    {
;;;322      return uwTick;
000002  6800              LDR      r0,[r0,#0]  ; uwTick
;;;323    }
000004  4770              BX       lr
;;;324    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      uwTick

                          AREA ||i.HAL_GetTickFreq||, CODE, READONLY, ALIGN=2

                  HAL_GetTickFreq PROC
;;;357      */
;;;358    HAL_TickFreqTypeDef HAL_GetTickFreq(void)
000000  4801              LDR      r0,|L13.8|
;;;359    {
;;;360      return uwTickFreq;
000002  7800              LDRB     r0,[r0,#0]  ; uwTickFreq
;;;361    }
000004  4770              BX       lr
;;;362    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      uwTickFreq

                          AREA ||i.HAL_GetTickPrio||, CODE, READONLY, ALIGN=2

                  HAL_GetTickPrio PROC
;;;328      */
;;;329    uint32_t HAL_GetTickPrio(void)
000000  4801              LDR      r0,|L14.8|
;;;330    {
;;;331      return uwTickPrio;
000002  6800              LDR      r0,[r0,#0]  ; uwTickPrio
;;;332    }
000004  4770              BX       lr
;;;333    
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      uwTickPrio

                          AREA ||i.HAL_GetUID||, CODE, READONLY, ALIGN=2

                  HAL_GetUID PROC
;;;570      */
;;;571    void HAL_GetUID(uint32_t *UID)
000000  4905              LDR      r1,|L15.24|
;;;572    {
;;;573      UID[0] = (uint32_t)(READ_REG(*((uint32_t *)UID_BASE)));
000002  6809              LDR      r1,[r1,#0]
000004  6001              STR      r1,[r0,#0]
;;;574      UID[1] = (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE + 4U))));
000006  4904              LDR      r1,|L15.24|
000008  1d09              ADDS     r1,r1,#4
00000a  6809              LDR      r1,[r1,#0]
00000c  6041              STR      r1,[r0,#4]
;;;575      UID[2] = (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE + 8U))));
00000e  4902              LDR      r1,|L15.24|
000010  3108              ADDS     r1,r1,#8
000012  6809              LDR      r1,[r1,#0]
000014  6081              STR      r1,[r0,#8]
;;;576    }
000016  4770              BX       lr
;;;577    
                          ENDP

                  |L15.24|
                          DCD      0x1ffff7e8

                          AREA ||i.HAL_IncTick||, CODE, READONLY, ALIGN=2

                  HAL_IncTick PROC
;;;308      */
;;;309    __weak void HAL_IncTick(void)
000000  4803              LDR      r0,|L16.16|
;;;310    {
;;;311      uwTick += uwTickFreq; 
000002  6800              LDR      r0,[r0,#0]  ; uwTick
000004  4903              LDR      r1,|L16.20|
000006  7809              LDRB     r1,[r1,#0]  ; uwTickFreq
000008  4408              ADD      r0,r0,r1
00000a  4901              LDR      r1,|L16.16|
00000c  6008              STR      r0,[r1,#0]  ; uwTick
;;;312    }
00000e  4770              BX       lr
;;;313    
                          ENDP

                  |L16.16|
                          DCD      uwTick
                  |L16.20|
                          DCD      uwTickFreq

                          AREA ||i.HAL_Init||, CODE, READONLY, ALIGN=2

                  HAL_Init PROC
;;;157      */
;;;158    HAL_StatusTypeDef HAL_Init(void)
000000  b510              PUSH     {r4,lr}
;;;159    {
;;;160      /* Configure Flash prefetch */
;;;161    #if (PREFETCH_ENABLE != 0)
;;;162    #if defined(STM32F101x6) || defined(STM32F101xB) || defined(STM32F101xE) || defined(STM32F101xG) || \
;;;163        defined(STM32F102x6) || defined(STM32F102xB) || \
;;;164        defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || \
;;;165        defined(STM32F105xC) || defined(STM32F107xC)
;;;166    
;;;167      /* Prefetch buffer is not available on value line devices */
;;;168      __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
000002  4808              LDR      r0,|L17.36|
000004  6800              LDR      r0,[r0,#0]
000006  f0400010          ORR      r0,r0,#0x10
00000a  4906              LDR      r1,|L17.36|
00000c  6008              STR      r0,[r1,#0]
;;;169    #endif
;;;170    #endif /* PREFETCH_ENABLE */
;;;171    
;;;172      /* Set Interrupt Group Priority */
;;;173      HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
00000e  2003              MOVS     r0,#3
000010  f7fffffe          BL       HAL_NVIC_SetPriorityGrouping
;;;174    
;;;175      /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
;;;176      HAL_InitTick(TICK_INT_PRIORITY);
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       HAL_InitTick
;;;177    
;;;178      /* Init the low level hardware */
;;;179      HAL_MspInit();
00001a  f7fffffe          BL       HAL_MspInit
;;;180    
;;;181      /* Return function status */
;;;182      return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;183    }
000020  bd10              POP      {r4,pc}
;;;184    
                          ENDP

000022  0000              DCW      0x0000
                  |L17.36|
                          DCD      0x40022000

                          AREA ||i.HAL_InitTick||, CODE, READONLY, ALIGN=2

                  HAL_InitTick PROC
;;;249      */
;;;250    __weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
000000  b570              PUSH     {r4-r6,lr}
;;;251    {
000002  4604              MOV      r4,r0
;;;252      /* Configure the SysTick to have interrupt in 1ms time basis*/
;;;253      if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
000004  480e              LDR      r0,|L18.64|
000006  7800              LDRB     r0,[r0,#0]  ; uwTickFreq
000008  f44f717a          MOV      r1,#0x3e8
00000c  fbb1f0f0          UDIV     r0,r1,r0
000010  490c              LDR      r1,|L18.68|
000012  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
000014  fbb1f5f0          UDIV     r5,r1,r0
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       HAL_SYSTICK_Config
00001e  b108              CBZ      r0,|L18.36|
;;;254      {
;;;255        return HAL_ERROR;
000020  2001              MOVS     r0,#1
                  |L18.34|
;;;256      }
;;;257    
;;;258      /* Configure the SysTick IRQ priority */
;;;259      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
;;;260      {
;;;261        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
;;;262        uwTickPrio = TickPriority;
;;;263      }
;;;264      else
;;;265      {
;;;266        return HAL_ERROR;
;;;267      }
;;;268    
;;;269      /* Return function status */
;;;270      return HAL_OK;
;;;271    }
000022  bd70              POP      {r4-r6,pc}
                  |L18.36|
000024  2c10              CMP      r4,#0x10              ;259
000026  d207              BCS      |L18.56|
000028  2200              MOVS     r2,#0                 ;261
00002a  4621              MOV      r1,r4                 ;261
00002c  1e50              SUBS     r0,r2,#1              ;261
00002e  f7fffffe          BL       HAL_NVIC_SetPriority
000032  4805              LDR      r0,|L18.72|
000034  6004              STR      r4,[r0,#0]            ;262  ; uwTickPrio
000036  e001              B        |L18.60|
                  |L18.56|
000038  2001              MOVS     r0,#1                 ;266
00003a  e7f2              B        |L18.34|
                  |L18.60|
00003c  2000              MOVS     r0,#0                 ;270
00003e  e7f0              B        |L18.34|
;;;272    
                          ENDP

                  |L18.64|
                          DCD      uwTickFreq
                  |L18.68|
                          DCD      SystemCoreClock
                  |L18.72|
                          DCD      uwTickPrio

                          AREA ||i.HAL_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_MspDeInit PROC
;;;226      */
;;;227    __weak void HAL_MspDeInit(void)
000000  4770              BX       lr
;;;228    {
;;;229      /* NOTE : This function should not be modified, when the callback is needed,
;;;230                the HAL_MspDeInit could be implemented in the user file
;;;231       */
;;;232    }
;;;233    
                          ENDP


                          AREA ||i.HAL_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_MspInit PROC
;;;215      */
;;;216    __weak void HAL_MspInit(void)
000000  4770              BX       lr
;;;217    {
;;;218      /* NOTE : This function should not be modified, when the callback is needed,
;;;219                the HAL_MspInit could be implemented in the user file
;;;220       */
;;;221    }
;;;222    
                          ENDP


                          AREA ||i.HAL_ResumeTick||, CODE, READONLY, ALIGN=1

                  HAL_ResumeTick PROC
;;;415      */
;;;416    __weak void HAL_ResumeTick(void)
000000  f04f20e0          MOV      r0,#0xe000e000
;;;417    {
;;;418      /* Enable SysTick Interrupt */
;;;419      SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
000004  6900              LDR      r0,[r0,#0x10]
000006  f0400002          ORR      r0,r0,#2
00000a  f04f21e0          MOV      r1,#0xe000e000
00000e  6108              STR      r0,[r1,#0x10]
;;;420    }
000010  4770              BX       lr
;;;421    
                          ENDP


                          AREA ||i.HAL_SetTickFreq||, CODE, READONLY, ALIGN=2

                  HAL_SetTickFreq PROC
;;;337      */
;;;338    HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)
000000  b570              PUSH     {r4-r6,lr}
;;;339    {
000002  4604              MOV      r4,r0
;;;340      HAL_StatusTypeDef status  = HAL_OK;
000004  2500              MOVS     r5,#0
;;;341      assert_param(IS_TICKFREQ(Freq));
;;;342    
;;;343      if (uwTickFreq != Freq)
000006  4806              LDR      r0,|L22.32|
000008  7800              LDRB     r0,[r0,#0]  ; uwTickFreq
00000a  42a0              CMP      r0,r4
00000c  d006              BEQ      |L22.28|
;;;344      {
;;;345        uwTickFreq = Freq;
00000e  4804              LDR      r0,|L22.32|
000010  7004              STRB     r4,[r0,#0]
;;;346    
;;;347        /* Apply the new tick Freq  */
;;;348        status = HAL_InitTick(uwTickPrio);
000012  4804              LDR      r0,|L22.36|
000014  6800              LDR      r0,[r0,#0]  ; uwTickPrio
000016  f7fffffe          BL       HAL_InitTick
00001a  4605              MOV      r5,r0
                  |L22.28|
;;;349      }
;;;350    
;;;351      return status;
00001c  4628              MOV      r0,r5
;;;352    }
00001e  bd70              POP      {r4-r6,pc}
;;;353    
                          ENDP

                  |L22.32|
                          DCD      uwTickFreq
                  |L22.36|
                          DCD      uwTickPrio

                          AREA ||i.HAL_SuspendTick||, CODE, READONLY, ALIGN=1

                  HAL_SuspendTick PROC
;;;399      */
;;;400    __weak void HAL_SuspendTick(void)
000000  f04f20e0          MOV      r0,#0xe000e000
;;;401    {
;;;402      /* Disable SysTick Interrupt */
;;;403      CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
000004  6900              LDR      r0,[r0,#0x10]
000006  f0200002          BIC      r0,r0,#2
00000a  f04f21e0          MOV      r1,#0xe000e000
00000e  6108              STR      r0,[r1,#0x10]
;;;404    }
000010  4770              BX       lr
;;;405    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  uwTick
                          DCD      0x00000000
                  uwTickPrio
                          DCD      0x00000010
                  uwTickFreq
000008  01                DCB      0x01

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f1xx_hal_c_3da258af____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___15_stm32f1xx_hal_c_3da258af____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f1xx_hal_c_3da258af____REVSH|
#line 402
|__asm___15_stm32f1xx_hal_c_3da258af____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f1xx_hal_c_3da258af____RRX|
#line 587
|__asm___15_stm32f1xx_hal_c_3da258af____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
