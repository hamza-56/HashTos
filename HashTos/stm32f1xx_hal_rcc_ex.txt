; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -orcc\stm32f1xx_hal_rcc_ex.o --asm_dir=..\ --list_dir=..\ --depend=rcc\stm32f1xx_hal_rcc_ex.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -ID:\RCCv2\RCC\RCC\MDK-ARM\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=rcc\stm32f1xx_hal_rcc_ex.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc_ex.c]
                          THUMB

                          AREA ||i.HAL_RCCEx_GetPeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKConfig PROC
;;;309      */
;;;310    void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  2100              MOVS     r1,#0
;;;311    {
;;;312      uint32_t srcclk = 0U;
;;;313      
;;;314      /* Set all possible values for the extended clock type parameter------------*/
;;;315      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_RTC;
000002  2201              MOVS     r2,#1
000004  6002              STR      r2,[r0,#0]
;;;316    
;;;317      /* Get the RTC configuration -----------------------------------------------*/
;;;318      srcclk = __HAL_RCC_GET_RTC_SOURCE();
000006  4a0c              LDR      r2,|L1.56|
000008  6a12              LDR      r2,[r2,#0x20]
00000a  f4027140          AND      r1,r2,#0x300
;;;319      /* Source clock is LSE or LSI*/
;;;320      PeriphClkInit->RTCClockSelection = srcclk;
00000e  6041              STR      r1,[r0,#4]
;;;321    
;;;322      /* Get the ADC clock configuration -----------------------------------------*/
;;;323      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_ADC;
000010  6802              LDR      r2,[r0,#0]
000012  f0420202          ORR      r2,r2,#2
000016  6002              STR      r2,[r0,#0]
;;;324      PeriphClkInit->AdcClockSelection = __HAL_RCC_GET_ADC_SOURCE();
000018  4a07              LDR      r2,|L1.56|
00001a  6852              LDR      r2,[r2,#4]
00001c  f4024240          AND      r2,r2,#0xc000
000020  6082              STR      r2,[r0,#8]
;;;325    
;;;326    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;327      /* Get the I2S2 clock configuration -----------------------------------------*/
;;;328      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S2;
;;;329      PeriphClkInit->I2s2ClockSelection = __HAL_RCC_GET_I2S2_SOURCE();
;;;330    
;;;331      /* Get the I2S3 clock configuration -----------------------------------------*/
;;;332      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S3;
;;;333      PeriphClkInit->I2s3ClockSelection = __HAL_RCC_GET_I2S3_SOURCE();
;;;334    
;;;335    #endif /* STM32F105xC || STM32F107xC */
;;;336    
;;;337    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;338      /* Get the I2S2 clock configuration -----------------------------------------*/
;;;339      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S2;
;;;340      PeriphClkInit->I2s2ClockSelection = RCC_I2S2CLKSOURCE_SYSCLK;
;;;341    
;;;342      /* Get the I2S3 clock configuration -----------------------------------------*/
;;;343      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S3;
;;;344      PeriphClkInit->I2s3ClockSelection = RCC_I2S3CLKSOURCE_SYSCLK;
;;;345    
;;;346    #endif /* STM32F103xE || STM32F103xG */
;;;347    
;;;348    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;349     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;350     || defined(STM32F105xC) || defined(STM32F107xC)
;;;351      /* Get the USB clock configuration -----------------------------------------*/
;;;352      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_USB;
000022  6802              LDR      r2,[r0,#0]
000024  f0420210          ORR      r2,r2,#0x10
000028  6002              STR      r2,[r0,#0]
;;;353      PeriphClkInit->UsbClockSelection = __HAL_RCC_GET_USB_SOURCE();
00002a  4a03              LDR      r2,|L1.56|
00002c  6852              LDR      r2,[r2,#4]
00002e  f4020280          AND      r2,r2,#0x400000
000032  60c2              STR      r2,[r0,#0xc]
;;;354    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;355    }
000034  4770              BX       lr
;;;356    
                          ENDP

000036  0000              DCW      0x0000
                  |L1.56|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_GetPeriphCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKFreq PROC
;;;402      */
;;;403    uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;404    {
000004  b085              SUB      sp,sp,#0x14
000006  4606              MOV      r6,r0
;;;405    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;406      const uint8_t aPLLMULFactorTable[14] = {0, 0, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 13};
;;;407      const uint8_t aPredivFactorTable[16] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
;;;408    
;;;409      uint32_t prediv1 = 0U, pllclk = 0U, pllmul = 0U;
;;;410      uint32_t pll2mul = 0U, pll3mul = 0U, prediv2 = 0U;
;;;411    #endif /* STM32F105xC || STM32F107xC */
;;;412    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6) || \
;;;413        defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)
;;;414      const uint8_t aPLLMULFactorTable[16] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16};
000008  a33d              ADR      r3,|L2.256|
00000a  cb0f              LDM      r3,{r0-r3}
00000c  ac01              ADD      r4,sp,#4
00000e  c40f              STM      r4!,{r0-r3}
;;;415      const uint8_t aPredivFactorTable[2] = {1, 2};
000010  a03f              ADR      r0,|L2.272|
000012  6800              LDR      r0,[r0,#0]
000014  9000              STR      r0,[sp,#0]
;;;416    
;;;417      uint32_t prediv1 = 0U, pllclk = 0U, pllmul = 0U;
000016  f04f0800          MOV      r8,#0
00001a  2500              MOVS     r5,#0
00001c  2700              MOVS     r7,#0
;;;418    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG */
;;;419      uint32_t temp_reg = 0U, frequency = 0U;
00001e  2400              MOVS     r4,#0
000020  46a1              MOV      r9,r4
;;;420    
;;;421      /* Check the parameters */
;;;422      assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));
;;;423      
;;;424      switch (PeriphClk)
000022  2e01              CMP      r6,#1
000024  d030              BEQ      |L2.136|
000026  2e02              CMP      r6,#2
000028  d058              BEQ      |L2.220|
00002a  2e10              CMP      r6,#0x10
00002c  d161              BNE      |L2.242|
;;;425      {
;;;426    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;427     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;428     || defined(STM32F105xC) || defined(STM32F107xC)
;;;429      case RCC_PERIPHCLK_USB:  
;;;430        {
;;;431          /* Get RCC configuration ------------------------------------------------------*/
;;;432          temp_reg = RCC->CFGR;
00002e  4839              LDR      r0,|L2.276|
000030  6844              LDR      r4,[r0,#4]
;;;433      
;;;434          /* Check if PLL is enabled */
;;;435          if (HAL_IS_BIT_SET(RCC->CR,RCC_CR_PLLON))
000032  6800              LDR      r0,[r0,#0]
000034  f0007080          AND      r0,r0,#0x1000000
000038  b300              CBZ      r0,|L2.124|
;;;436          {
;;;437            pllmul = aPLLMULFactorTable[(uint32_t)(temp_reg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
00003a  a801              ADD      r0,sp,#4
00003c  f3c44183          UBFX     r1,r4,#18,#4
000040  5c47              LDRB     r7,[r0,r1]
;;;438            if ((temp_reg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
000042  f4043080          AND      r0,r4,#0x10000
000046  b170              CBZ      r0,|L2.102|
;;;439            {
;;;440    #if defined(STM32F105xC) || defined(STM32F107xC) || defined(STM32F100xB)\
;;;441     || defined(STM32F100xE)
;;;442              prediv1 = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV1) >> RCC_CFGR2_PREDIV1_Pos];
;;;443    #else
;;;444              prediv1 = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
000048  4832              LDR      r0,|L2.276|
00004a  6840              LDR      r0,[r0,#4]
00004c  f3c04040          UBFX     r0,r0,#17,#1
000050  f81d8000          LDRB     r8,[sp,r0]
;;;445    #endif /* STM32F105xC || STM32F107xC || STM32F100xB || STM32F100xE */
;;;446    
;;;447    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;448              if(HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_PREDIV1SRC))
;;;449              {
;;;450                /* PLL2 selected as Prediv1 source */
;;;451                /* PLLCLK = PLL2CLK / PREDIV1 * PLLMUL with PLL2CLK = HSE/PREDIV2 * PLL2MUL */
;;;452                prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> RCC_CFGR2_PREDIV2_Pos) + 1;
;;;453                pll2mul = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> RCC_CFGR2_PLL2MUL_Pos) + 2;
;;;454                pllclk = (uint32_t)((((HSE_VALUE / prediv2) * pll2mul) / prediv1) * pllmul);
;;;455              }
;;;456              else
;;;457              {
;;;458                /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;459                pllclk = (uint32_t)((HSE_VALUE / prediv1) * pllmul);
;;;460              }
;;;461              
;;;462              /* If PLLMUL was set to 13 means that it was to cover the case PLLMUL 6.5 (avoid using float) */
;;;463              /* In this case need to divide pllclk by 2 */
;;;464              if (pllmul == aPLLMULFactorTable[(uint32_t)(RCC_CFGR_PLLMULL6_5) >> RCC_CFGR_PLLMULL_Pos])
;;;465              {
;;;466                  pllclk = pllclk / 2;
;;;467              }
;;;468    #else
;;;469              if ((temp_reg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
000054  f4043080          AND      r0,r4,#0x10000
000058  b140              CBZ      r0,|L2.108|
;;;470              {
;;;471                /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;472                pllclk = (uint32_t)((HSE_VALUE / prediv1) * pllmul);
00005a  482f              LDR      r0,|L2.280|
00005c  fbb0f0f8          UDIV     r0,r0,r8
000060  fb00f507          MUL      r5,r0,r7
000064  e002              B        |L2.108|
                  |L2.102|
;;;473              }
;;;474    #endif /* STM32F105xC || STM32F107xC */
;;;475            }
;;;476            else
;;;477            {
;;;478              /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
;;;479              pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
000066  482d              LDR      r0,|L2.284|
000068  fb07f500          MUL      r5,r7,r0
                  |L2.108|
;;;480            }
;;;481    
;;;482            /* Calcul of the USB frequency*/
;;;483    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;484            /* USBCLK = PLLVCO = (2 x PLLCLK) / USB prescaler */
;;;485            if (__HAL_RCC_GET_USB_SOURCE() == RCC_USBCLKSOURCE_PLL_DIV2)
;;;486            {
;;;487              /* Prescaler of 2 selected for USB */ 
;;;488              frequency = pllclk;
;;;489            }
;;;490            else
;;;491            {
;;;492              /* Prescaler of 3 selected for USB */ 
;;;493              frequency = (2 * pllclk) / 3;
;;;494            }
;;;495    #else
;;;496            /* USBCLK = PLLCLK / USB prescaler */
;;;497            if (__HAL_RCC_GET_USB_SOURCE() == RCC_USBCLKSOURCE_PLL)
00006c  4829              LDR      r0,|L2.276|
00006e  6840              LDR      r0,[r0,#4]
000070  f4000080          AND      r0,r0,#0x400000
000074  f5b00f80          CMP      r0,#0x400000
000078  d101              BNE      |L2.126|
;;;498            {
;;;499              /* No prescaler selected for USB */
;;;500              frequency = pllclk;
00007a  46a9              MOV      r9,r5
                  |L2.124|
00007c  e003              B        |L2.134|
                  |L2.126|
;;;501            }
;;;502            else
;;;503            {
;;;504              /* Prescaler of 1.5 selected for USB */ 
;;;505              frequency = (pllclk * 2) / 3;
00007e  0068              LSLS     r0,r5,#1
000080  2103              MOVS     r1,#3
000082  fbb0f9f1          UDIV     r9,r0,r1
                  |L2.134|
;;;506            }
;;;507    #endif
;;;508          }
;;;509          break;
000086  e035              B        |L2.244|
                  |L2.136|
;;;510        }
;;;511    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;512    #if defined(STM32F103xE) || defined(STM32F103xG) || defined(STM32F105xC) || defined(STM32F107xC)
;;;513      case RCC_PERIPHCLK_I2S2:  
;;;514        {
;;;515    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;516          /* SYSCLK used as source clock for I2S2 */
;;;517          frequency = HAL_RCC_GetSysClockFreq();
;;;518    #else
;;;519          if (__HAL_RCC_GET_I2S2_SOURCE() == RCC_I2S2CLKSOURCE_SYSCLK)
;;;520          {
;;;521            /* SYSCLK used as source clock for I2S2 */
;;;522            frequency = HAL_RCC_GetSysClockFreq();
;;;523          }
;;;524          else
;;;525          {
;;;526             /* Check if PLLI2S is enabled */
;;;527            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3ON))
;;;528            {
;;;529              /* PLLI2SVCO = 2 * PLLI2SCLK = 2 * (HSE/PREDIV2 * PLL3MUL) */
;;;530              prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> RCC_CFGR2_PREDIV2_Pos) + 1;
;;;531              pll3mul = ((RCC->CFGR2 & RCC_CFGR2_PLL3MUL) >> RCC_CFGR2_PLL3MUL_Pos) + 2;
;;;532              frequency = (uint32_t)(2 * ((HSE_VALUE / prediv2) * pll3mul));
;;;533            }
;;;534          }
;;;535    #endif /* STM32F103xE || STM32F103xG */
;;;536          break;
;;;537        }
;;;538      case RCC_PERIPHCLK_I2S3:
;;;539        {
;;;540    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;541          /* SYSCLK used as source clock for I2S3 */
;;;542          frequency = HAL_RCC_GetSysClockFreq();
;;;543    #else
;;;544          if (__HAL_RCC_GET_I2S3_SOURCE() == RCC_I2S3CLKSOURCE_SYSCLK)
;;;545          {
;;;546            /* SYSCLK used as source clock for I2S3 */
;;;547            frequency = HAL_RCC_GetSysClockFreq();
;;;548          }
;;;549          else
;;;550          {
;;;551             /* Check if PLLI2S is enabled */
;;;552            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3ON))
;;;553            {
;;;554              /* PLLI2SVCO = 2 * PLLI2SCLK = 2 * (HSE/PREDIV2 * PLL3MUL) */
;;;555              prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> RCC_CFGR2_PREDIV2_Pos) + 1;
;;;556              pll3mul = ((RCC->CFGR2 & RCC_CFGR2_PLL3MUL) >> RCC_CFGR2_PLL3MUL_Pos) + 2;
;;;557              frequency = (uint32_t)(2 * ((HSE_VALUE / prediv2) * pll3mul));
;;;558            }
;;;559          }
;;;560    #endif /* STM32F103xE || STM32F103xG */
;;;561          break;
;;;562        }
;;;563    #endif /* STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;564      case RCC_PERIPHCLK_RTC:  
;;;565        {
;;;566          /* Get RCC BDCR configuration ------------------------------------------------------*/
;;;567          temp_reg = RCC->BDCR;
000088  4822              LDR      r0,|L2.276|
00008a  6a04              LDR      r4,[r0,#0x20]
;;;568    
;;;569          /* Check if LSE is ready if RTC clock selection is LSE */
;;;570          if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSERDY)))
00008c  f4047040          AND      r0,r4,#0x300
000090  f5b07f80          CMP      r0,#0x100
000094  d105              BNE      |L2.162|
000096  f0040002          AND      r0,r4,#2
00009a  b110              CBZ      r0,|L2.162|
;;;571          {
;;;572            frequency = LSE_VALUE;
00009c  f44f4900          MOV      r9,#0x8000
0000a0  e01b              B        |L2.218|
                  |L2.162|
;;;573          }
;;;574          /* Check if LSI is ready if RTC clock selection is LSI */
;;;575          else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
0000a2  f4047040          AND      r0,r4,#0x300
0000a6  f5b07f00          CMP      r0,#0x200
0000aa  d107              BNE      |L2.188|
0000ac  4819              LDR      r0,|L2.276|
0000ae  6a40              LDR      r0,[r0,#0x24]
0000b0  f0000002          AND      r0,r0,#2
0000b4  b110              CBZ      r0,|L2.188|
;;;576          {
;;;577            frequency = LSI_VALUE;
0000b6  f6494940          MOV      r9,#0x9c40
0000ba  e00e              B        |L2.218|
                  |L2.188|
;;;578          }
;;;579          else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_HSE_DIV128) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)))
0000bc  f4047040          AND      r0,r4,#0x300
0000c0  f5b07f40          CMP      r0,#0x300
0000c4  d107              BNE      |L2.214|
0000c6  4813              LDR      r0,|L2.276|
0000c8  6800              LDR      r0,[r0,#0]
0000ca  f4003000          AND      r0,r0,#0x20000
0000ce  b110              CBZ      r0,|L2.214|
;;;580          {
;;;581            frequency = HSE_VALUE / 128U;
0000d0  f24f4924          MOV      r9,#0xf424
0000d4  e001              B        |L2.218|
                  |L2.214|
;;;582          }
;;;583          /* Clock not enabled for RTC*/
;;;584          else
;;;585          {
;;;586            frequency = 0U;
0000d6  f04f0900          MOV      r9,#0
                  |L2.218|
;;;587          }
;;;588          break;
0000da  e00b              B        |L2.244|
                  |L2.220|
;;;589        }
;;;590      case RCC_PERIPHCLK_ADC:  
;;;591        {
;;;592          frequency = HAL_RCC_GetPCLK2Freq() / (((__HAL_RCC_GET_ADC_SOURCE() >> RCC_CFGR_ADCPRE_Pos) + 1) * 2);
0000dc  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0000e0  490c              LDR      r1,|L2.276|
0000e2  6849              LDR      r1,[r1,#4]
0000e4  f3c13181          UBFX     r1,r1,#14,#2
0000e8  1c49              ADDS     r1,r1,#1
0000ea  0049              LSLS     r1,r1,#1
0000ec  fbb0f9f1          UDIV     r9,r0,r1
;;;593          break;
0000f0  e000              B        |L2.244|
                  |L2.242|
;;;594        }
;;;595      default: 
;;;596        {
;;;597          break;
0000f2  bf00              NOP      
                  |L2.244|
0000f4  bf00              NOP                            ;509
;;;598        }
;;;599      }
;;;600      return(frequency);
0000f6  4648              MOV      r0,r9
;;;601    }
0000f8  b005              ADD      sp,sp,#0x14
0000fa  e8bd83f0          POP      {r4-r9,pc}
;;;602    
                          ENDP

0000fe  0000              DCW      0x0000
                  |L2.256|
000100  02030405          DCB      2,3,4,5,6,"\a\b\t\n\v\f\r",14,15,16,16
000104  06070809
000108  0a0b0c0d
00010c  0e0f1010
                  |L2.272|
000110  010200            DCB      1,2,0
000113  00                DCB      0
                  |L2.276|
                          DCD      0x40021000
                  |L2.280|
                          DCD      0x007a1200
                  |L2.284|
                          DCD      0x003d0900

                          AREA ||i.HAL_RCCEx_PeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_PeriphCLKConfig PROC
;;;115      */
;;;116    HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  b5f8              PUSH     {r3-r7,lr}
;;;117    {
000002  4604              MOV      r4,r0
;;;118      uint32_t tickstart = 0U, temp_reg = 0U;
000004  2600              MOVS     r6,#0
000006  2500              MOVS     r5,#0
;;;119    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;120      uint32_t  pllactive = 0U;
;;;121    #endif /* STM32F105xC || STM32F107xC */
;;;122    
;;;123      /* Check the parameters */
;;;124      assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
;;;125      
;;;126      /*------------------------------- RTC/LCD Configuration ------------------------*/ 
;;;127      if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
000008  7820              LDRB     r0,[r4,#0]
00000a  f0000001          AND      r0,r0,#1
00000e  2800              CMP      r0,#0
000010  d06b              BEQ      |L3.234|
;;;128      {
;;;129        /* check for RTC Parameters used to output RTCCLK */
;;;130        assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
;;;131    
;;;132        FlagStatus       pwrclkchanged = RESET;
000012  2700              MOVS     r7,#0
;;;133    
;;;134        /* As soon as function is called to change RTC clock source, activation of the 
;;;135           power domain is done. */
;;;136        /* Requires to enable write access to Backup Domain of necessary */
;;;137        if(__HAL_RCC_PWR_IS_CLK_DISABLED())
000014  4843              LDR      r0,|L3.292|
000016  69c0              LDR      r0,[r0,#0x1c]
000018  f0005080          AND      r0,r0,#0x10000000
00001c  b970              CBNZ     r0,|L3.60|
;;;138        {
;;;139        __HAL_RCC_PWR_CLK_ENABLE();
00001e  bf00              NOP      
000020  4840              LDR      r0,|L3.292|
000022  69c0              LDR      r0,[r0,#0x1c]
000024  f0405080          ORR      r0,r0,#0x10000000
000028  493e              LDR      r1,|L3.292|
00002a  61c8              STR      r0,[r1,#0x1c]
00002c  4608              MOV      r0,r1
00002e  69c0              LDR      r0,[r0,#0x1c]
000030  f0005080          AND      r0,r0,#0x10000000
000034  9000              STR      r0,[sp,#0]
000036  bf00              NOP      
000038  bf00              NOP      
;;;140          pwrclkchanged = SET;
00003a  2701              MOVS     r7,#1
                  |L3.60|
;;;141        }
;;;142        
;;;143        if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
00003c  483a              LDR      r0,|L3.296|
00003e  6800              LDR      r0,[r0,#0]
000040  f4007080          AND      r0,r0,#0x100
000044  b9b0              CBNZ     r0,|L3.116|
;;;144        {
;;;145          /* Enable write access to Backup domain */
;;;146          SET_BIT(PWR->CR, PWR_CR_DBP);
000046  4838              LDR      r0,|L3.296|
000048  6800              LDR      r0,[r0,#0]
00004a  f4407080          ORR      r0,r0,#0x100
00004e  4936              LDR      r1,|L3.296|
000050  6008              STR      r0,[r1,#0]
;;;147          
;;;148          /* Wait for Backup domain Write protection disable */
;;;149          tickstart = HAL_GetTick();
000052  f7fffffe          BL       HAL_GetTick
000056  4606              MOV      r6,r0
;;;150          
;;;151          while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
000058  e006              B        |L3.104|
                  |L3.90|
;;;152          {
;;;153            if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
00005a  f7fffffe          BL       HAL_GetTick
00005e  1b80              SUBS     r0,r0,r6
000060  2864              CMP      r0,#0x64
000062  d901              BLS      |L3.104|
;;;154            {
;;;155              return HAL_TIMEOUT;
000064  2003              MOVS     r0,#3
                  |L3.102|
;;;156            }
;;;157          }
;;;158        }
;;;159          
;;;160        /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
;;;161        temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
;;;162        if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
;;;163        {
;;;164          /* Store the content of BDCR register before the reset of Backup Domain */
;;;165          temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
;;;166          /* RTC Clock selection can be changed only if the Backup Domain is reset */
;;;167          __HAL_RCC_BACKUPRESET_FORCE();
;;;168          __HAL_RCC_BACKUPRESET_RELEASE();
;;;169          /* Restore the Content of BDCR register */
;;;170          RCC->BDCR = temp_reg;
;;;171    
;;;172          /* Wait for LSERDY if LSE was enabled */
;;;173          if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
;;;174          {
;;;175            /* Get Start Tick */
;;;176            tickstart = HAL_GetTick();
;;;177          
;;;178            /* Wait till LSE is ready */  
;;;179            while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
;;;180            {
;;;181              if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
;;;182              {
;;;183                return HAL_TIMEOUT;
;;;184              }      
;;;185            }  
;;;186          }
;;;187        }
;;;188        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection); 
;;;189    
;;;190        /* Require to disable power clock if necessary */
;;;191        if(pwrclkchanged == SET)
;;;192        {
;;;193          __HAL_RCC_PWR_CLK_DISABLE();
;;;194        }
;;;195      }
;;;196    
;;;197      /*------------------------------ ADC clock Configuration ------------------*/ 
;;;198      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
;;;199      {
;;;200        /* Check the parameters */
;;;201        assert_param(IS_RCC_ADCPLLCLK_DIV(PeriphClkInit->AdcClockSelection));
;;;202        
;;;203        /* Configure the ADC clock source */
;;;204        __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
;;;205      }
;;;206    
;;;207    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;208      /*------------------------------ I2S2 Configuration ------------------------*/ 
;;;209      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S2) == RCC_PERIPHCLK_I2S2)
;;;210      {
;;;211        /* Check the parameters */
;;;212        assert_param(IS_RCC_I2S2CLKSOURCE(PeriphClkInit->I2s2ClockSelection));
;;;213    
;;;214        /* Configure the I2S2 clock source */
;;;215        __HAL_RCC_I2S2_CONFIG(PeriphClkInit->I2s2ClockSelection);
;;;216      }
;;;217    
;;;218      /*------------------------------ I2S3 Configuration ------------------------*/ 
;;;219      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S3) == RCC_PERIPHCLK_I2S3)
;;;220      {
;;;221        /* Check the parameters */
;;;222        assert_param(IS_RCC_I2S3CLKSOURCE(PeriphClkInit->I2s3ClockSelection));
;;;223        
;;;224        /* Configure the I2S3 clock source */
;;;225        __HAL_RCC_I2S3_CONFIG(PeriphClkInit->I2s3ClockSelection);
;;;226      }
;;;227    
;;;228      /*------------------------------ PLL I2S Configuration ----------------------*/ 
;;;229      /* Check that PLLI2S need to be enabled */
;;;230      if (HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_I2S2SRC) || HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_I2S3SRC))
;;;231      {
;;;232        /* Update flag to indicate that PLL I2S should be active */
;;;233        pllactive = 1;
;;;234      }
;;;235    
;;;236      /* Check if PLL I2S need to be enabled */
;;;237      if (pllactive == 1)
;;;238      {
;;;239        /* Enable PLL I2S only if not active */
;;;240        if (HAL_IS_BIT_CLR(RCC->CR, RCC_CR_PLL3ON))
;;;241        {
;;;242          /* Check the parameters */
;;;243          assert_param(IS_RCC_PLLI2S_MUL(PeriphClkInit->PLLI2S.PLLI2SMUL));
;;;244          assert_param(IS_RCC_HSE_PREDIV2(PeriphClkInit->PLLI2S.HSEPrediv2Value));
;;;245    
;;;246          /* Prediv2 can be written only when the PLL2 is disabled. */
;;;247          /* Return an error only if new value is different from the programmed value */
;;;248          if (HAL_IS_BIT_SET(RCC->CR,RCC_CR_PLL2ON) && \
;;;249            (__HAL_RCC_HSE_GET_PREDIV2() != PeriphClkInit->PLLI2S.HSEPrediv2Value))
;;;250          {
;;;251            return HAL_ERROR;
;;;252          }
;;;253    
;;;254          /* Configure the HSE prediv2 factor --------------------------------*/
;;;255          __HAL_RCC_HSE_PREDIV2_CONFIG(PeriphClkInit->PLLI2S.HSEPrediv2Value);
;;;256    
;;;257          /* Configure the main PLLI2S multiplication factors. */
;;;258          __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SMUL);
;;;259          
;;;260          /* Enable the main PLLI2S. */
;;;261          __HAL_RCC_PLLI2S_ENABLE();
;;;262          
;;;263          /* Get Start Tick*/
;;;264          tickstart = HAL_GetTick();
;;;265          
;;;266          /* Wait till PLLI2S is ready */
;;;267          while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
;;;268          {
;;;269            if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
;;;270            {
;;;271              return HAL_TIMEOUT;
;;;272            }
;;;273          }
;;;274        }
;;;275        else
;;;276        {
;;;277          /* Return an error only if user wants to change the PLLI2SMUL whereas PLLI2S is active */
;;;278          if (READ_BIT(RCC->CFGR2, RCC_CFGR2_PLL3MUL) != PeriphClkInit->PLLI2S.PLLI2SMUL)
;;;279          {
;;;280              return HAL_ERROR;
;;;281          }
;;;282        }
;;;283      }
;;;284    #endif /* STM32F105xC || STM32F107xC */
;;;285    
;;;286    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;287     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;288     || defined(STM32F105xC) || defined(STM32F107xC)
;;;289      /*------------------------------ USB clock Configuration ------------------*/ 
;;;290      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
;;;291      {
;;;292        /* Check the parameters */
;;;293        assert_param(IS_RCC_USBPLLCLK_DIV(PeriphClkInit->UsbClockSelection));
;;;294        
;;;295        /* Configure the USB clock source */
;;;296        __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
;;;297      }
;;;298    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;299    
;;;300      return HAL_OK;
;;;301    }
000066  bdf8              POP      {r3-r7,pc}
                  |L3.104|
000068  482f              LDR      r0,|L3.296|
00006a  6800              LDR      r0,[r0,#0]            ;151
00006c  f4007080          AND      r0,r0,#0x100          ;151
000070  2800              CMP      r0,#0                 ;151
000072  d0f2              BEQ      |L3.90|
                  |L3.116|
000074  482b              LDR      r0,|L3.292|
000076  6a00              LDR      r0,[r0,#0x20]         ;161
000078  f4007540          AND      r5,r0,#0x300          ;161
00007c  b32d              CBZ      r5,|L3.202|
00007e  88a0              LDRH     r0,[r4,#4]            ;162
000080  f4007040          AND      r0,r0,#0x300          ;162
000084  42a8              CMP      r0,r5                 ;162
000086  d020              BEQ      |L3.202|
000088  4826              LDR      r0,|L3.292|
00008a  6a00              LDR      r0,[r0,#0x20]         ;165
00008c  f4207540          BIC      r5,r0,#0x300          ;165
000090  2001              MOVS     r0,#1                 ;167
000092  4926              LDR      r1,|L3.300|
000094  6008              STR      r0,[r1,#0]            ;167
000096  2000              MOVS     r0,#0                 ;168
000098  6008              STR      r0,[r1,#0]            ;168
00009a  4822              LDR      r0,|L3.292|
00009c  6205              STR      r5,[r0,#0x20]         ;170
00009e  f0050001          AND      r0,r5,#1              ;173
0000a2  b190              CBZ      r0,|L3.202|
0000a4  f7fffffe          BL       HAL_GetTick
0000a8  4606              MOV      r6,r0                 ;176
0000aa  e008              B        |L3.190|
                  |L3.172|
0000ac  f7fffffe          BL       HAL_GetTick
0000b0  1b80              SUBS     r0,r0,r6              ;181
0000b2  f2413188          MOV      r1,#0x1388            ;181
0000b6  4288              CMP      r0,r1                 ;181
0000b8  d901              BLS      |L3.190|
0000ba  2003              MOVS     r0,#3                 ;183
0000bc  e7d3              B        |L3.102|
                  |L3.190|
0000be  4819              LDR      r0,|L3.292|
0000c0  6a00              LDR      r0,[r0,#0x20]         ;179
0000c2  f0000002          AND      r0,r0,#2              ;179
0000c6  2800              CMP      r0,#0                 ;179
0000c8  d0f0              BEQ      |L3.172|
                  |L3.202|
0000ca  4816              LDR      r0,|L3.292|
0000cc  6a00              LDR      r0,[r0,#0x20]         ;188
0000ce  f4207040          BIC      r0,r0,#0x300          ;188
0000d2  6861              LDR      r1,[r4,#4]            ;188
0000d4  4308              ORRS     r0,r0,r1              ;188
0000d6  4913              LDR      r1,|L3.292|
0000d8  6208              STR      r0,[r1,#0x20]         ;188
0000da  2f01              CMP      r7,#1                 ;191
0000dc  d104              BNE      |L3.232|
0000de  4608              MOV      r0,r1                 ;193
0000e0  69c0              LDR      r0,[r0,#0x1c]         ;193
0000e2  f0205080          BIC      r0,r0,#0x10000000     ;193
0000e6  61c8              STR      r0,[r1,#0x1c]         ;193
                  |L3.232|
0000e8  bf00              NOP                            ;195
                  |L3.234|
0000ea  7820              LDRB     r0,[r4,#0]            ;198
0000ec  f0000002          AND      r0,r0,#2              ;198
0000f0  2802              CMP      r0,#2                 ;198
0000f2  d107              BNE      |L3.260|
0000f4  480b              LDR      r0,|L3.292|
0000f6  6840              LDR      r0,[r0,#4]            ;204
0000f8  f4204040          BIC      r0,r0,#0xc000         ;204
0000fc  68a1              LDR      r1,[r4,#8]            ;204
0000fe  4308              ORRS     r0,r0,r1              ;204
000100  4908              LDR      r1,|L3.292|
000102  6048              STR      r0,[r1,#4]            ;204
                  |L3.260|
000104  7820              LDRB     r0,[r4,#0]            ;290
000106  f0000010          AND      r0,r0,#0x10           ;290
00010a  2810              CMP      r0,#0x10              ;290
00010c  d107              BNE      |L3.286|
00010e  4805              LDR      r0,|L3.292|
000110  6840              LDR      r0,[r0,#4]            ;296
000112  f4200080          BIC      r0,r0,#0x400000       ;296
000116  68e1              LDR      r1,[r4,#0xc]          ;296
000118  4308              ORRS     r0,r0,r1              ;296
00011a  4902              LDR      r1,|L3.292|
00011c  6048              STR      r0,[r1,#4]            ;296
                  |L3.286|
00011e  2000              MOVS     r0,#0                 ;300
000120  e7a1              B        |L3.102|
;;;302    
                          ENDP

000122  0000              DCW      0x0000
                  |L3.292|
                          DCD      0x40021000
                  |L3.296|
                          DCD      0x40007000
                  |L3.300|
                          DCD      0x42420440

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REVSH|
#line 402
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____RRX|
#line 587
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
