; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -orcc\stm32f1xx_hal_pwr.o --asm_dir=..\ --list_dir=..\ --depend=rcc\stm32f1xx_hal_pwr.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -ID:\RCCv2\RCC\RCC\MDK-ARM\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=rcc\stm32f1xx_hal_pwr.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c]
                          THUMB

                          AREA ||i.HAL_PWR_ConfigPVD||, CODE, READONLY, ALIGN=2

                  HAL_PWR_ConfigPVD PROC
;;;331      */
;;;332    void HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)
000000  492a              LDR      r1,|L1.172|
;;;333    {
;;;334      /* Check the parameters */
;;;335      assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
;;;336      assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));
;;;337    
;;;338      /* Set PLS[7:5] bits according to PVDLevel value */
;;;339      MODIFY_REG(PWR->CR, PWR_CR_PLS, sConfigPVD->PVDLevel);
000002  6809              LDR      r1,[r1,#0]
000004  f02101e0          BIC      r1,r1,#0xe0
000008  6802              LDR      r2,[r0,#0]
00000a  4311              ORRS     r1,r1,r2
00000c  4a27              LDR      r2,|L1.172|
00000e  6011              STR      r1,[r2,#0]
;;;340      
;;;341      /* Clear any previous config. Keep it clear if no event or IT mode is selected */
;;;342      __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
000010  4927              LDR      r1,|L1.176|
000012  6809              LDR      r1,[r1,#0]
000014  f4213180          BIC      r1,r1,#0x10000
000018  4a25              LDR      r2,|L1.176|
00001a  6011              STR      r1,[r2,#0]
;;;343      __HAL_PWR_PVD_EXTI_DISABLE_IT();
00001c  1f11              SUBS     r1,r2,#4
00001e  6809              LDR      r1,[r1,#0]
000020  f4213180          BIC      r1,r1,#0x10000
000024  1f12              SUBS     r2,r2,#4
000026  6011              STR      r1,[r2,#0]
;;;344      __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); 
000028  4921              LDR      r1,|L1.176|
00002a  3108              ADDS     r1,r1,#8
00002c  6809              LDR      r1,[r1,#0]
00002e  f4213180          BIC      r1,r1,#0x10000
000032  4a1f              LDR      r2,|L1.176|
000034  3208              ADDS     r2,r2,#8
000036  6011              STR      r1,[r2,#0]
;;;345      __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();
000038  1f11              SUBS     r1,r2,#4
00003a  6809              LDR      r1,[r1,#0]
00003c  f4213180          BIC      r1,r1,#0x10000
000040  1f12              SUBS     r2,r2,#4
000042  6011              STR      r1,[r2,#0]
;;;346    
;;;347      /* Configure interrupt mode */
;;;348      if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
000044  6841              LDR      r1,[r0,#4]
000046  f4013180          AND      r1,r1,#0x10000
00004a  f5b13f80          CMP      r1,#0x10000
00004e  d107              BNE      |L1.96|
;;;349      {
;;;350        __HAL_PWR_PVD_EXTI_ENABLE_IT();
000050  4917              LDR      r1,|L1.176|
000052  1f09              SUBS     r1,r1,#4
000054  6809              LDR      r1,[r1,#0]
000056  f4413180          ORR      r1,r1,#0x10000
00005a  4a15              LDR      r2,|L1.176|
00005c  1f12              SUBS     r2,r2,#4
00005e  6011              STR      r1,[r2,#0]
                  |L1.96|
;;;351      }
;;;352      
;;;353      /* Configure event mode */
;;;354      if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
000060  6841              LDR      r1,[r0,#4]
000062  f4013100          AND      r1,r1,#0x20000
000066  f5b13f00          CMP      r1,#0x20000
00006a  d105              BNE      |L1.120|
;;;355      {
;;;356        __HAL_PWR_PVD_EXTI_ENABLE_EVENT();
00006c  4910              LDR      r1,|L1.176|
00006e  6809              LDR      r1,[r1,#0]
000070  f4413180          ORR      r1,r1,#0x10000
000074  4a0e              LDR      r2,|L1.176|
000076  6011              STR      r1,[r2,#0]
                  |L1.120|
;;;357      }
;;;358      
;;;359      /* Configure the edge */
;;;360      if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
000078  7901              LDRB     r1,[r0,#4]
00007a  f0010101          AND      r1,r1,#1
00007e  b139              CBZ      r1,|L1.144|
;;;361      {
;;;362        __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();
000080  490b              LDR      r1,|L1.176|
000082  1d09              ADDS     r1,r1,#4
000084  6809              LDR      r1,[r1,#0]
000086  f4413180          ORR      r1,r1,#0x10000
00008a  4a09              LDR      r2,|L1.176|
00008c  1d12              ADDS     r2,r2,#4
00008e  6011              STR      r1,[r2,#0]
                  |L1.144|
;;;363      }
;;;364      
;;;365      if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
000090  7901              LDRB     r1,[r0,#4]
000092  f0010102          AND      r1,r1,#2
000096  2902              CMP      r1,#2
000098  d107              BNE      |L1.170|
;;;366      {
;;;367        __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
00009a  4905              LDR      r1,|L1.176|
00009c  3108              ADDS     r1,r1,#8
00009e  6809              LDR      r1,[r1,#0]
0000a0  f4413180          ORR      r1,r1,#0x10000
0000a4  4a02              LDR      r2,|L1.176|
0000a6  3208              ADDS     r2,r2,#8
0000a8  6011              STR      r1,[r2,#0]
                  |L1.170|
;;;368      }
;;;369    }
0000aa  4770              BX       lr
;;;370    
                          ENDP

                  |L1.172|
                          DCD      0x40007000
                  |L1.176|
                          DCD      0x40010404

                          AREA ||i.HAL_PWR_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_PWR_DeInit PROC
;;;171      */
;;;172    void HAL_PWR_DeInit(void)
000000  4805              LDR      r0,|L2.24|
;;;173    {
;;;174      __HAL_RCC_PWR_FORCE_RESET();
000002  6900              LDR      r0,[r0,#0x10]
000004  f0405080          ORR      r0,r0,#0x10000000
000008  4903              LDR      r1,|L2.24|
00000a  6108              STR      r0,[r1,#0x10]
;;;175      __HAL_RCC_PWR_RELEASE_RESET();
00000c  4608              MOV      r0,r1
00000e  6900              LDR      r0,[r0,#0x10]
000010  f0205080          BIC      r0,r0,#0x10000000
000014  6108              STR      r0,[r1,#0x10]
;;;176    }
000016  4770              BX       lr
;;;177    
                          ENDP

                  |L2.24|
                          DCD      0x40021000

                          AREA ||i.HAL_PWR_DisableBkUpAccess||, CODE, READONLY, ALIGN=2

                  HAL_PWR_DisableBkUpAccess PROC
;;;197      */
;;;198    void HAL_PWR_DisableBkUpAccess(void)
000000  2000              MOVS     r0,#0
;;;199    {
;;;200      /* Disable access to RTC and backup registers */
;;;201      *(__IO uint32_t *) CR_DBP_BB = (uint32_t)DISABLE;
000002  4901              LDR      r1,|L3.8|
000004  6208              STR      r0,[r1,#0x20]
;;;202    }
000006  4770              BX       lr
;;;203    
                          ENDP

                  |L3.8|
                          DCD      0x420e0000

                          AREA ||i.HAL_PWR_DisablePVD||, CODE, READONLY, ALIGN=2

                  HAL_PWR_DisablePVD PROC
;;;384      */
;;;385    void HAL_PWR_DisablePVD(void)
000000  2000              MOVS     r0,#0
;;;386    {
;;;387      /* Disable the power voltage detector */
;;;388      *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)DISABLE;
000002  4901              LDR      r1,|L4.8|
000004  6108              STR      r0,[r1,#0x10]
;;;389    }
000006  4770              BX       lr
;;;390    
                          ENDP

                  |L4.8|
                          DCD      0x420e0000

                          AREA ||i.HAL_PWR_DisableSEVOnPend||, CODE, READONLY, ALIGN=2

                  HAL_PWR_DisableSEVOnPend PROC
;;;582      */
;;;583    void HAL_PWR_DisableSEVOnPend(void)
000000  4803              LDR      r0,|L5.16|
;;;584    {
;;;585      /* Clear SEVONPEND bit of Cortex System Control Register */
;;;586      CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
000002  6800              LDR      r0,[r0,#0]
000004  f0200010          BIC      r0,r0,#0x10
000008  4901              LDR      r1,|L5.16|
00000a  6008              STR      r0,[r1,#0]
;;;587    }
00000c  4770              BX       lr
;;;588    
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWR_DisableSleepOnExit||, CODE, READONLY, ALIGN=2

                  HAL_PWR_DisableSleepOnExit PROC
;;;556      */
;;;557    void HAL_PWR_DisableSleepOnExit(void)
000000  4803              LDR      r0,|L6.16|
;;;558    {
;;;559      /* Clear SLEEPONEXIT bit of Cortex System Control Register */
;;;560      CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
000002  6800              LDR      r0,[r0,#0]
000004  f0200002          BIC      r0,r0,#2
000008  4901              LDR      r1,|L6.16|
00000a  6008              STR      r0,[r1,#0]
;;;561    }
00000c  4770              BX       lr
;;;562    
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWR_DisableWakeUpPin||, CODE, READONLY, ALIGN=2

                  HAL_PWR_DisableWakeUpPin PROC
;;;412      */
;;;413    void HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)
000000  2100              MOVS     r1,#0
;;;414    {
;;;415      /* Check the parameter */
;;;416      assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
;;;417      /* Disable the EWUPx pin */
;;;418      *(__IO uint32_t *) CSR_EWUP_BB(WakeUpPinx) = (uint32_t)DISABLE;
000002  fa90f2a0          RBIT     r2,r0
000006  fab2f282          CLZ      r2,r2
00000a  4b03              LDR      r3,|L7.24|
00000c  eb030282          ADD      r2,r3,r2,LSL #2
000010  f8c21080          STR      r1,[r2,#0x80]
;;;419    }
000014  4770              BX       lr
;;;420    
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      0x420e0000

                          AREA ||i.HAL_PWR_EnableBkUpAccess||, CODE, READONLY, ALIGN=2

                  HAL_PWR_EnableBkUpAccess PROC
;;;184      */
;;;185    void HAL_PWR_EnableBkUpAccess(void)
000000  2001              MOVS     r0,#1
;;;186    {
;;;187      /* Enable access to RTC and backup registers */
;;;188      *(__IO uint32_t *) CR_DBP_BB = (uint32_t)ENABLE;
000002  4901              LDR      r1,|L8.8|
000004  6208              STR      r0,[r1,#0x20]
;;;189    }
000006  4770              BX       lr
;;;190    
                          ENDP

                  |L8.8|
                          DCD      0x420e0000

                          AREA ||i.HAL_PWR_EnablePVD||, CODE, READONLY, ALIGN=2

                  HAL_PWR_EnablePVD PROC
;;;374      */
;;;375    void HAL_PWR_EnablePVD(void)
000000  2001              MOVS     r0,#1
;;;376    {
;;;377      /* Enable the power voltage detector */
;;;378      *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)ENABLE;
000002  4901              LDR      r1,|L9.8|
000004  6108              STR      r0,[r1,#0x10]
;;;379    }
000006  4770              BX       lr
;;;380    
                          ENDP

                  |L9.8|
                          DCD      0x420e0000

                          AREA ||i.HAL_PWR_EnableSEVOnPend||, CODE, READONLY, ALIGN=2

                  HAL_PWR_EnableSEVOnPend PROC
;;;569      */
;;;570    void HAL_PWR_EnableSEVOnPend(void)
000000  4803              LDR      r0,|L10.16|
;;;571    {
;;;572      /* Set SEVONPEND bit of Cortex System Control Register */
;;;573      SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
000002  6800              LDR      r0,[r0,#0]
000004  f0400010          ORR      r0,r0,#0x10
000008  4901              LDR      r1,|L10.16|
00000a  6008              STR      r0,[r1,#0]
;;;574    }
00000c  4770              BX       lr
;;;575    
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWR_EnableSleepOnExit||, CODE, READONLY, ALIGN=2

                  HAL_PWR_EnableSleepOnExit PROC
;;;543      */
;;;544    void HAL_PWR_EnableSleepOnExit(void)
000000  4803              LDR      r0,|L11.16|
;;;545    {
;;;546      /* Set SLEEPONEXIT bit of Cortex System Control Register */
;;;547      SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
000002  6800              LDR      r0,[r0,#0]
000004  f0400002          ORR      r0,r0,#2
000008  4901              LDR      r1,|L11.16|
00000a  6008              STR      r0,[r1,#0]
;;;548    }
00000c  4770              BX       lr
;;;549    
                          ENDP

00000e  0000              DCW      0x0000
                  |L11.16|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWR_EnableWakeUpPin||, CODE, READONLY, ALIGN=2

                  HAL_PWR_EnableWakeUpPin PROC
;;;397      */
;;;398    void HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinx)
000000  2101              MOVS     r1,#1
;;;399    {
;;;400      /* Check the parameter */
;;;401      assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
;;;402      /* Enable the EWUPx pin */
;;;403      *(__IO uint32_t *) CSR_EWUP_BB(WakeUpPinx) = (uint32_t)ENABLE;
000002  fa90f2a0          RBIT     r2,r0
000006  fab2f282          CLZ      r2,r2
00000a  4b03              LDR      r3,|L12.24|
00000c  eb030282          ADD      r2,r3,r2,LSL #2
000010  f8c21080          STR      r1,[r2,#0x80]
;;;404    }
000014  4770              BX       lr
;;;405    
                          ENDP

000016  0000              DCW      0x0000
                  |L12.24|
                          DCD      0x420e0000

                          AREA ||i.HAL_PWR_EnterSLEEPMode||, CODE, READONLY, ALIGN=2

                  HAL_PWR_EnterSLEEPMode PROC
;;;432      */
;;;433    void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
000000  4a06              LDR      r2,|L13.28|
;;;434    {
;;;435      /* Check the parameters */
;;;436      /* No check on Regulator because parameter not used in SLEEP mode */
;;;437      /* Prevent unused argument(s) compilation warning */
;;;438      UNUSED(Regulator);
;;;439    
;;;440      assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));
;;;441    
;;;442      /* Clear SLEEPDEEP bit of Cortex System Control Register */
;;;443      CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
000002  6812              LDR      r2,[r2,#0]
000004  f0220204          BIC      r2,r2,#4
000008  4b04              LDR      r3,|L13.28|
00000a  601a              STR      r2,[r3,#0]
;;;444    
;;;445      /* Select SLEEP mode entry -------------------------------------------------*/
;;;446      if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
00000c  2901              CMP      r1,#1
00000e  d101              BNE      |L13.20|
;;;447      {
;;;448        /* Request Wait For Interrupt */
;;;449        __WFI();
000010  bf30              WFI      
000012  e002              B        |L13.26|
                  |L13.20|
;;;450      }
;;;451      else
;;;452      {
;;;453        /* Request Wait For Event */
;;;454        __SEV();
000014  bf40              SEV      
;;;455        __WFE();
000016  bf20              WFE      
;;;456        __WFE();
000018  bf20              WFE      
                  |L13.26|
;;;457      }
;;;458    }
00001a  4770              BX       lr
;;;459    
                          ENDP

                  |L13.28|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWR_EnterSTANDBYMode||, CODE, READONLY, ALIGN=2

                  HAL_PWR_EnterSTANDBYMode PROC
;;;518      */
;;;519    void HAL_PWR_EnterSTANDBYMode(void)
000000  4807              LDR      r0,|L14.32|
;;;520    {
;;;521      /* Select Standby mode */
;;;522      SET_BIT(PWR->CR, PWR_CR_PDDS);
000002  6800              LDR      r0,[r0,#0]
000004  f0400002          ORR      r0,r0,#2
000008  4905              LDR      r1,|L14.32|
00000a  6008              STR      r0,[r1,#0]
;;;523    
;;;524      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;525      SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
00000c  4805              LDR      r0,|L14.36|
00000e  6800              LDR      r0,[r0,#0]
000010  f0400004          ORR      r0,r0,#4
000014  4903              LDR      r1,|L14.36|
000016  6008              STR      r0,[r1,#0]
;;;526    
;;;527      /* This option is used to ensure that store operations are completed */
;;;528    #if defined ( __CC_ARM)
;;;529      __force_stores();
000018  bf00              NOP      
00001a  bf00              NOP      
;;;530    #endif
;;;531      /* Request Wait For Interrupt */
;;;532      __WFI();
00001c  bf30              WFI      
;;;533    }
00001e  4770              BX       lr
;;;534    
                          ENDP

                  |L14.32|
                          DCD      0x40007000
                  |L14.36|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWR_EnterSTOPMode||, CODE, READONLY, ALIGN=2

                  HAL_PWR_EnterSTOPMode PROC
;;;478      */
;;;479    void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
000000  b570              PUSH     {r4-r6,lr}
;;;480    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;481      /* Check the parameters */
;;;482      assert_param(IS_PWR_REGULATOR(Regulator));
;;;483      assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
;;;484    
;;;485      /* Clear PDDS bit in PWR register to specify entering in STOP mode when CPU enter in Deepsleep */ 
;;;486      CLEAR_BIT(PWR->CR,  PWR_CR_PDDS);
000006  4811              LDR      r0,|L15.76|
000008  6800              LDR      r0,[r0,#0]
00000a  f0200002          BIC      r0,r0,#2
00000e  490f              LDR      r1,|L15.76|
000010  6008              STR      r0,[r1,#0]
;;;487    
;;;488      /* Select the voltage regulator mode by setting LPDS bit in PWR register according to Regulator parameter value */
;;;489      MODIFY_REG(PWR->CR, PWR_CR_LPDS, Regulator);
000012  4608              MOV      r0,r1
000014  6800              LDR      r0,[r0,#0]
000016  f0200001          BIC      r0,r0,#1
00001a  4320              ORRS     r0,r0,r4
00001c  6008              STR      r0,[r1,#0]
;;;490    
;;;491      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;492      SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
00001e  480c              LDR      r0,|L15.80|
000020  6800              LDR      r0,[r0,#0]
000022  f0400004          ORR      r0,r0,#4
000026  490a              LDR      r1,|L15.80|
000028  6008              STR      r0,[r1,#0]
;;;493    
;;;494      /* Select Stop mode entry --------------------------------------------------*/
;;;495      if(STOPEntry == PWR_STOPENTRY_WFI)
00002a  2d01              CMP      r5,#1
00002c  d101              BNE      |L15.50|
;;;496      {
;;;497        /* Request Wait For Interrupt */
;;;498        __WFI();
00002e  bf30              WFI      
000030  e004              B        |L15.60|
                  |L15.50|
;;;499      }
;;;500      else
;;;501      {
;;;502        /* Request Wait For Event */
;;;503        __SEV();
000032  bf40              SEV      
;;;504        PWR_OverloadWfe(); /* WFE redefine locally */
000034  f7fffffe          BL       PWR_OverloadWfe
;;;505        PWR_OverloadWfe(); /* WFE redefine locally */
000038  f7fffffe          BL       PWR_OverloadWfe
                  |L15.60|
;;;506      }
;;;507      /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;508      CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
00003c  4804              LDR      r0,|L15.80|
00003e  6800              LDR      r0,[r0,#0]
000040  f0200004          BIC      r0,r0,#4
000044  4902              LDR      r1,|L15.80|
000046  6008              STR      r0,[r1,#0]
;;;509    }
000048  bd70              POP      {r4-r6,pc}
;;;510    
                          ENDP

00004a  0000              DCW      0x0000
                  |L15.76|
                          DCD      0x40007000
                  |L15.80|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWR_PVDCallback||, CODE, READONLY, ALIGN=1

                  HAL_PWR_PVDCallback PROC
;;;612      */
;;;613    __weak void HAL_PWR_PVDCallback(void)
000000  4770              BX       lr
;;;614    {
;;;615      /* NOTE : This function Should not be modified, when the callback is needed,
;;;616                the HAL_PWR_PVDCallback could be implemented in the user file
;;;617       */ 
;;;618    }
;;;619    
                          ENDP


                          AREA ||i.HAL_PWR_PVD_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_PWR_PVD_IRQHandler PROC
;;;595      */
;;;596    void HAL_PWR_PVD_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;597    {
;;;598      /* Check PWR exti flag */
;;;599      if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)
000002  4806              LDR      r0,|L17.28|
000004  6800              LDR      r0,[r0,#0]
000006  f4003080          AND      r0,r0,#0x10000
00000a  b128              CBZ      r0,|L17.24|
;;;600      {
;;;601        /* PWR PVD interrupt user callback */
;;;602        HAL_PWR_PVDCallback();
00000c  f7fffffe          BL       HAL_PWR_PVDCallback
;;;603    
;;;604        /* Clear PWR Exti pending bit */
;;;605        __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
000010  f44f3080          MOV      r0,#0x10000
000014  4901              LDR      r1,|L17.28|
000016  6008              STR      r0,[r1,#0]
                  |L17.24|
;;;606      }
;;;607    }
000018  bd10              POP      {r4,pc}
;;;608    
                          ENDP

00001a  0000              DCW      0x0000
                  |L17.28|
                          DCD      0x40010414

                          AREA ||i.PWR_OverloadWfe||, CODE, READONLY, ALIGN=1

                  PWR_OverloadWfe PROC
                  ||__tagsym$$noinline||
;;;132    __NOINLINE
;;;133    static void PWR_OverloadWfe(void)
000000  bf20              WFE      
;;;134    {
;;;135      __asm volatile( "wfe" );
;;;136      __asm volatile( "nop" );
000002  bf00              NOP      
;;;137    }
000004  4770              BX       lr
;;;138    
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_pwr_c_f2cfe8be____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_pwr_c_f2cfe8be____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_pwr_c_f2cfe8be____REVSH|
#line 402
|__asm___19_stm32f1xx_hal_pwr_c_f2cfe8be____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_pwr_c_f2cfe8be____RRX|
#line 587
|__asm___19_stm32f1xx_hal_pwr_c_f2cfe8be____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
