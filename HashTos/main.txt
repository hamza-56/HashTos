; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -orcc\main.o --asm_dir=..\ --list_dir=..\ --depend=rcc\main.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -ID:\RCCv2\RCC\RCC\MDK-ARM\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=rcc\main.crf ../Src/main.c]
                          THUMB

                          AREA ||i.MX_GPIO_Init||, CODE, READONLY, ALIGN=2

                  MX_GPIO_Init PROC
;;;453     */
;;;454    static void MX_GPIO_Init(void) {
000000  b508              PUSH     {r3,lr}
;;;455      /* GPIO Ports Clock Enable */
;;;456      //__HAL_RCC_GPIOC_CLK_ENABLE();
;;;457    	__HAL_RCC_GPIOA_CLK_ENABLE();
000002  bf00              NOP      
000004  481d              LDR      r0,|L1.124|
000006  6980              LDR      r0,[r0,#0x18]
000008  f0400004          ORR      r0,r0,#4
00000c  491b              LDR      r1,|L1.124|
00000e  6188              STR      r0,[r1,#0x18]
000010  4608              MOV      r0,r1
000012  6980              LDR      r0,[r0,#0x18]
000014  f0000004          AND      r0,r0,#4
000018  9000              STR      r0,[sp,#0]
00001a  bf00              NOP      
00001c  bf00              NOP      
;;;458      /*Configure GPIO pin Output Level */
;;;459    	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
00001e  2200              MOVS     r2,#0
000020  2120              MOVS     r1,#0x20
000022  4817              LDR      r0,|L1.128|
000024  f7fffffe          BL       HAL_GPIO_WritePin
;;;460    	//HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);
;;;461    	
;;;462      /*Configure GPIO pin : PC13 */
;;;463      GPIO_InitStruct.Pin = GPIO_PIN_5;
000028  2020              MOVS     r0,#0x20
00002a  4916              LDR      r1,|L1.132|
00002c  6008              STR      r0,[r1,#0]  ; GPIO_InitStruct
;;;464      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
00002e  2001              MOVS     r0,#1
000030  6048              STR      r0,[r1,#4]  ; GPIO_InitStruct
;;;465      //GPIO_InitStruct.Pull = GPIO_NOPULL;3
;;;466      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
000032  2002              MOVS     r0,#2
000034  60c8              STR      r0,[r1,#0xc]  ; GPIO_InitStruct
;;;467      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
000036  4812              LDR      r0,|L1.128|
000038  f7fffffe          BL       HAL_GPIO_Init
;;;468    	
;;;469    	
;;;470    		__HAL_RCC_GPIOC_CLK_ENABLE();
00003c  bf00              NOP      
00003e  480f              LDR      r0,|L1.124|
000040  6980              LDR      r0,[r0,#0x18]
000042  f0400010          ORR      r0,r0,#0x10
000046  490d              LDR      r1,|L1.124|
000048  6188              STR      r0,[r1,#0x18]
00004a  4608              MOV      r0,r1
00004c  6980              LDR      r0,[r0,#0x18]
00004e  f0000010          AND      r0,r0,#0x10
000052  9000              STR      r0,[sp,#0]
000054  bf00              NOP      
000056  bf00              NOP      
;;;471      /*Configure GPIO pin Output Level */
;;;472    	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);
000058  2200              MOVS     r2,#0
00005a  f44f5100          MOV      r1,#0x2000
00005e  480a              LDR      r0,|L1.136|
000060  f7fffffe          BL       HAL_GPIO_WritePin
;;;473    	//HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);
;;;474    	
;;;475      /*Configure GPIO pin : PC13 */
;;;476      GPIO_InitStruct2.Pin = GPIO_PIN_13;
000064  f44f5000          MOV      r0,#0x2000
000068  4908              LDR      r1,|L1.140|
00006a  6008              STR      r0,[r1,#0]  ; GPIO_InitStruct2
;;;477      GPIO_InitStruct2.Mode = GPIO_MODE_OUTPUT_PP;
00006c  2001              MOVS     r0,#1
00006e  6048              STR      r0,[r1,#4]  ; GPIO_InitStruct2
;;;478      //GPIO_InitStruct.Pull = GPIO_NOPULL;3
;;;479      GPIO_InitStruct2.Speed = GPIO_SPEED_FREQ_LOW;
000070  2002              MOVS     r0,#2
000072  60c8              STR      r0,[r1,#0xc]  ; GPIO_InitStruct2
;;;480      HAL_GPIO_Init(GPIOC, &GPIO_InitStruct2);
000074  4804              LDR      r0,|L1.136|
000076  f7fffffe          BL       HAL_GPIO_Init
;;;481    	
;;;482    }
00007a  bd08              POP      {r3,pc}
;;;483    
                          ENDP

                  |L1.124|
                          DCD      0x40021000
                  |L1.128|
                          DCD      0x40010800
                  |L1.132|
                          DCD      GPIO_InitStruct
                  |L1.136|
                          DCD      0x40011000
                  |L1.140|
                          DCD      GPIO_InitStruct2

                          AREA ||i.NVIC_SetPriority||, CODE, READONLY, ALIGN=2

                  NVIC_SetPriority PROC
;;;1523    */
;;;1524   __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  b510              PUSH     {r4,lr}
;;;1525   {
;;;1526     if ((int32_t)(IRQn) < 0)
000002  2800              CMP      r0,#0
000004  da07              BGE      |L2.22|
;;;1527     {
;;;1528       SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000006  070a              LSLS     r2,r1,#28
000008  0e14              LSRS     r4,r2,#24
00000a  4a05              LDR      r2,|L2.32|
00000c  f000030f          AND      r3,r0,#0xf
000010  1f1b              SUBS     r3,r3,#4
000012  54d4              STRB     r4,[r2,r3]
000014  e003              B        |L2.30|
                  |L2.22|
;;;1529     }
;;;1530     else
;;;1531     {
;;;1532       NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000016  070a              LSLS     r2,r1,#28
000018  0e13              LSRS     r3,r2,#24
00001a  4a02              LDR      r2,|L2.36|
00001c  5413              STRB     r3,[r2,r0]
                  |L2.30|
;;;1533     }
;;;1534   }
00001e  bd10              POP      {r4,pc}
;;;1535   
                          ENDP

                  |L2.32|
                          DCD      0xe000ed18
                  |L2.36|
                          DCD      0xe000e400

                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=1

                  SysTick_Handler PROC
;;;270    }
;;;271    void SysTick_Handler(void) {
000000  b510              PUSH     {r4,lr}
;;;272      HAL_IncTick();
000002  f7fffffe          BL       HAL_IncTick
;;;273      HAL_SYSTICK_IRQHandler();
000006  f7fffffe          BL       HAL_SYSTICK_IRQHandler
;;;274    	
;;;275    	
;;;276      /*
;;;277    		register unsigned int cp15_control __asm("cp15:0:c1:c0:0");
;;;278    		cp15_control |= 0x1; 
;;;279    	*/
;;;280    
;;;281      /*
;;;282      __asm  { 
;;;283    		  MRS r0, __get_PSP
;;;284    	};
;;;285    	*/
;;;286    	if(os_scheduler())
00000a  f7fffffe          BL       os_scheduler
00000e  b118              CBZ      r0,|L3.24|
;;;287    	{
;;;288    _save_state();
000010  f7fffffe          BL       _save_state
;;;289    _load_state();
000014  f7fffffe          BL       _load_state
                  |L3.24|
;;;290    	}
;;;291    }
000018  bd10              POP      {r4,pc}
;;;292    
                          ENDP


                          AREA ||i.SystemClock_Config||, CODE, READONLY, ALIGN=2

                  SystemClock_Config PROC
;;;403     */
;;;404    void SystemClock_Config(void) {
000000  b510              PUSH     {r4,lr}
000002  b090              SUB      sp,sp,#0x40
;;;405    
;;;406      RCC_OscInitTypeDef RCC_OscInitStruct;
;;;407      RCC_ClkInitTypeDef RCC_ClkInitStruct;
;;;408    
;;;409      /**Initializes the CPU, AHB and APB busses clocks 
;;;410       */
;;;411      RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
000004  2001              MOVS     r0,#1
000006  9006              STR      r0,[sp,#0x18]
;;;412      RCC_OscInitStruct.HSEState = RCC_HSE_ON;
000008  0400              LSLS     r0,r0,#16
00000a  9007              STR      r0,[sp,#0x1c]
;;;413      RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
00000c  2000              MOVS     r0,#0
00000e  9008              STR      r0,[sp,#0x20]
;;;414      RCC_OscInitStruct.HSIState = RCC_HSI_ON;
000010  2001              MOVS     r0,#1
000012  900a              STR      r0,[sp,#0x28]
;;;415      RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
000014  2002              MOVS     r0,#2
000016  900d              STR      r0,[sp,#0x34]
;;;416      RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
000018  03c1              LSLS     r1,r0,#15
00001a  910e              STR      r1,[sp,#0x38]
;;;417      RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
00001c  f44f11e0          MOV      r1,#0x1c0000
000020  910f              STR      r1,[sp,#0x3c]
;;;418      if (HAL_RCC_OscConfig( &RCC_OscInitStruct) != HAL_OK) {
000022  a806              ADD      r0,sp,#0x18
000024  f7fffffe          BL       HAL_RCC_OscConfig
000028  b120              CBZ      r0,|L4.52|
;;;419        _Error_Handler(__FILE__, __LINE__);
00002a  f24011a3          MOV      r1,#0x1a3
00002e  a015              ADR      r0,|L4.132|
000030  f7fffffe          BL       _Error_Handler
                  |L4.52|
;;;420      }
;;;421    
;;;422      /**Initializes the CPU, AHB and APB busses clocks 
;;;423       */
;;;424      RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK |
000034  200f              MOVS     r0,#0xf
000036  9001              STR      r0,[sp,#4]
;;;425        RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
;;;426      RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
000038  2002              MOVS     r0,#2
00003a  9002              STR      r0,[sp,#8]
;;;427      RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
00003c  2000              MOVS     r0,#0
00003e  9003              STR      r0,[sp,#0xc]
;;;428      RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
000040  f44f6080          MOV      r0,#0x400
000044  9004              STR      r0,[sp,#0x10]
;;;429      RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
000046  2000              MOVS     r0,#0
000048  9005              STR      r0,[sp,#0x14]
;;;430    
;;;431      if (HAL_RCC_ClockConfig( &RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) {
00004a  2102              MOVS     r1,#2
00004c  a801              ADD      r0,sp,#4
00004e  f7fffffe          BL       HAL_RCC_ClockConfig
000052  b120              CBZ      r0,|L4.94|
;;;432        _Error_Handler(__FILE__, __LINE__);
000054  f44f71d8          MOV      r1,#0x1b0
000058  a00a              ADR      r0,|L4.132|
00005a  f7fffffe          BL       _Error_Handler
                  |L4.94|
;;;433      }
;;;434    
;;;435      /**Configure the Systick interrupt time 
;;;436       */
;;;437      HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / 1000);
00005e  f7fffffe          BL       HAL_RCC_GetHCLKFreq
000062  f44f717a          MOV      r1,#0x3e8
000066  fbb0f4f1          UDIV     r4,r0,r1
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       HAL_SYSTICK_Config
;;;438    
;;;439      /**Configure the Systick 
;;;440       */
;;;441      HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
000070  2004              MOVS     r0,#4
000072  f7fffffe          BL       HAL_SYSTICK_CLKSourceConfig
;;;442    
;;;443      /* SysTick_IRQn interrupt configuration */
;;;444      HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
000076  2200              MOVS     r2,#0
000078  4611              MOV      r1,r2
00007a  1e50              SUBS     r0,r2,#1
00007c  f7fffffe          BL       HAL_NVIC_SetPriority
;;;445    }
000080  b010              ADD      sp,sp,#0x40
000082  bd10              POP      {r4,pc}
;;;446    
                          ENDP

                  |L4.132|
000084  2e2e2f53          DCB      "../Src/main.c",0
000088  72632f6d
00008c  61696e2e
000090  6300    
000092  00                DCB      0
000093  00                DCB      0

                          AREA ||i._Error_Handler||, CODE, READONLY, ALIGN=1

                  _Error_Handler PROC
;;;493     */
;;;494    void _Error_Handler(char * file, int line) {
000000  bf00              NOP      
                  |L5.2|
;;;495      /* USER CODE BEGIN Error_Handler_Debug */
;;;496      /* User can add his own implementation to report the HAL error return state */
;;;497      while (1) {}
000002  e7fe              B        |L5.2|
;;;498      /* USER CODE END Error_Handler_Debug */
;;;499    }
;;;500    
                          ENDP


                          AREA ||i.blinky||, CODE, READONLY, ALIGN=2

                  blinky PROC
;;;292    
;;;293    void blinky(void * d) {
000000  b508              PUSH     {r3,lr}
000002  4604              MOV      r4,r0
;;;294      int temp = * ((int * ) d);
000004  6825              LDR      r5,[r4,#0]
;;;295      volatile int i = 0;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;296    	while(1){
00000a  e00c              B        |L6.38|
                  |L6.12|
;;;297    	i=0;
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;298    		HAL_GPIO_TogglePin(GPIOA,GPIO_PIN_5);
000010  2120              MOVS     r1,#0x20
000012  4805              LDR      r0,|L6.40|
000014  f7fffffe          BL       HAL_GPIO_TogglePin
;;;299        
;;;300    		while (i < temp) {
000018  e002              B        |L6.32|
                  |L6.26|
;;;301        /* Toggle LED on PA0 */
;;;302    		//HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);	
;;;303    		// Reset bit will turn on LED (because the logic is interved)
;;;304    		//delay(temp);
;;;305    		//HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);
;;;306    		//HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_13);
;;;307        //delay(temp);
;;;308    		
;;;309    		i++;
00001a  9800              LDR      r0,[sp,#0]
00001c  1c40              ADDS     r0,r0,#1
00001e  9000              STR      r0,[sp,#0]
                  |L6.32|
000020  9800              LDR      r0,[sp,#0]            ;300
000022  42a8              CMP      r0,r5                 ;300
000024  dbf9              BLT      |L6.26|
                  |L6.38|
000026  e7f1              B        |L6.12|
;;;310      }
;;;311    }
;;;312    	return;
;;;313    }
;;;314    
                          ENDP

                  |L6.40|
                          DCD      0x40010800

                          AREA ||i.blinky2||, CODE, READONLY, ALIGN=2

                  blinky2 PROC
;;;314    
;;;315    void blinky2(void * d) {
000000  b508              PUSH     {r3,lr}
000002  4604              MOV      r4,r0
;;;316      int temp = * ((int * ) d);
000004  6825              LDR      r5,[r4,#0]
;;;317      volatile int i = 0;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;318    while(1){
00000a  e00d              B        |L7.40|
                  |L7.12|
;;;319    	i = 0;
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;320    	HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_13);
000010  f44f5100          MOV      r1,#0x2000
000014  4805              LDR      r0,|L7.44|
000016  f7fffffe          BL       HAL_GPIO_TogglePin
;;;321      while (i < temp) {
00001a  e002              B        |L7.34|
                  |L7.28|
;;;322        /* Toggle LED on PA0 */
;;;323        // Reset bit will turn on LED (because the logic is interved)
;;;324    		//HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);
;;;325    		//HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_13);
;;;326        //delay(temp);
;;;327        // Set bit will turn off LED (because the logic is interved)
;;;328        //HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_13);
;;;329        //delay(temp);
;;;330        i++;
00001c  9800              LDR      r0,[sp,#0]
00001e  1c40              ADDS     r0,r0,#1
000020  9000              STR      r0,[sp,#0]
                  |L7.34|
000022  9800              LDR      r0,[sp,#0]            ;321
000024  42a8              CMP      r0,r5                 ;321
000026  dbf9              BLT      |L7.28|
                  |L7.40|
000028  e7f0              B        |L7.12|
;;;331      }
;;;332    }
;;;333    	return;
;;;334    }
;;;335    
                          ENDP

00002a  0000              DCW      0x0000
                  |L7.44|
                          DCD      0x40011000

                          AREA ||i.delay||, CODE, READONLY, ALIGN=1

                  delay PROC
;;;337    // Delay function
;;;338    void delay(unsigned int nCount) {
000000  b50c              PUSH     {r2,r3,lr}
;;;339      volatile unsigned int i, j;
;;;340    
;;;341      for (i = 0; i < nCount; i++)
000002  2100              MOVS     r1,#0
000004  9101              STR      r1,[sp,#4]
000006  e00d              B        |L8.36|
                  |L8.8|
;;;342        for (j = 0; j < 0x2AFF; j++);
000008  2100              MOVS     r1,#0
00000a  9100              STR      r1,[sp,#0]
00000c  e002              B        |L8.20|
                  |L8.14|
00000e  9900              LDR      r1,[sp,#0]
000010  1c49              ADDS     r1,r1,#1
000012  9100              STR      r1,[sp,#0]
                  |L8.20|
000014  f64222ff          MOV      r2,#0x2aff
000018  9900              LDR      r1,[sp,#0]
00001a  4291              CMP      r1,r2
00001c  d3f7              BCC      |L8.14|
00001e  9901              LDR      r1,[sp,#4]            ;341
000020  1c49              ADDS     r1,r1,#1              ;341
000022  9101              STR      r1,[sp,#4]            ;341
                  |L8.36|
000024  9901              LDR      r1,[sp,#4]            ;341
000026  4281              CMP      r1,r0                 ;341
000028  d3ee              BCC      |L8.8|
;;;343    }
00002a  bd0c              POP      {r2,r3,pc}
;;;344    
                          ENDP


                          AREA ||i.get_next_task||, CODE, READONLY, ALIGN=2

                  get_next_task PROC
;;;223    
;;;224    uint32_t get_next_task() {
000000  490a              LDR      r1,|L9.44|
;;;225    	uint32_t next_task_id = m_task_table.current_task;
000002  f89100c8          LDRB     r0,[r1,#0xc8]  ; m_task_table
;;;226    	do {
000006  bf00              NOP      
                  |L9.8|
;;;227    		next_task_id++;
000008  1c40              ADDS     r0,r0,#1
;;;228    		next_task_id %= m_task_table.size;
00000a  4908              LDR      r1,|L9.44|
00000c  f8b110ca          LDRH     r1,[r1,#0xca]  ; m_task_table
000010  fbb0f2f1          UDIV     r2,r0,r1
000014  fb010012          MLS      r0,r1,r2,r0
;;;229    	} while(m_task_table.tasks[next_task_id].status == OS_TASK_STATUS_SUSPENDED);
000018  eb000180          ADD      r1,r0,r0,LSL #2
00001c  4a03              LDR      r2,|L9.44|
00001e  eb020181          ADD      r1,r2,r1,LSL #2
000022  7c09              LDRB     r1,[r1,#0x10]
000024  2903              CMP      r1,#3
000026  d0ef              BEQ      |L9.8|
;;;230    	return next_task_id;
;;;231    }
000028  4770              BX       lr
;;;232    
                          ENDP

00002a  0000              DCW      0x0000
                  |L9.44|
                          DCD      m_task_table

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;344    
;;;345    int main(void) {
000000  b57c              PUSH     {r2-r6,lr}
;;;346      /* USER CODE BEGIN 1 */
;;;347    
;;;348      /* USER CODE END 1 */
;;;349    
;;;350      /* MCU Configuration----------------------------------------------------------*/
;;;351    
;;;352      /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
;;;353      HAL_Init();
000002  f7fffffe          BL       HAL_Init
;;;354    
;;;355      /* USER CODE BEGIN Init */
;;;356    
;;;357      /* USER CODE END Init */
;;;358    
;;;359      /* Configure the system clock */
;;;360      SystemClock_Config();
000006  f7fffffe          BL       SystemClock_Config
;;;361    
;;;362      /* USER CODE BEGIN SysInit */
;;;363    
;;;364      /* USER CODE END SysInit */
;;;365    
;;;366      /* Initialize all configured peripherals */
;;;367      MX_GPIO_Init();
00000a  f7fffffe          BL       MX_GPIO_Init
;;;368      /* USER CODE BEGIN 2 */
;;;369    
;;;370      /* USER CODE END 2 */
;;;371    
;;;372      /* Infinite loop */
;;;373      /* USER CODE BEGIN WHILE */
;;;374    
;;;375      uint32_t delay = 100000;
00000e  4813              LDR      r0,|L10.92|
000010  9001              STR      r0,[sp,#4]
;;;376    	uint32_t delay2 = 1000000;
000012  4c13              LDR      r4,|L10.96|
;;;377      //while(1)
;;;378      //{
;;;379     // blinky((void*)&delay);
;;;380      //blinky((void*)&delay2);
;;;381      //}
;;;382      os_init();
000014  f7fffffe          BL       os_init
;;;383      memset(&stack1, 0xFF, 128);
000018  22ff              MOVS     r2,#0xff
00001a  2180              MOVS     r1,#0x80
00001c  4811              LDR      r0,|L10.100|
00001e  f7fffffe          BL       __aeabi_memset
;;;384    	memset(&stack2, 0xFF, 128);
000022  22ff              MOVS     r2,#0xff
000024  2180              MOVS     r1,#0x80
000026  4810              LDR      r0,|L10.104|
000028  f7fffffe          BL       __aeabi_memset
;;;385      uint8_t task_1 = os_task_init(blinky2, (void * ) &delay, 3,(uint32_t*) &stack1, 128/4);
00002c  2020              MOVS     r0,#0x20
00002e  4b0d              LDR      r3,|L10.100|
000030  2203              MOVS     r2,#3
000032  a901              ADD      r1,sp,#4
000034  9000              STR      r0,[sp,#0]
000036  480d              LDR      r0,|L10.108|
000038  f7fffffe          BL       os_task_init
00003c  b2c5              UXTB     r5,r0
;;;386      uint8_t task_2 = os_task_init(blinky, (void * ) &delay, 30,(uint32_t*) &stack2, 128/4);
00003e  2020              MOVS     r0,#0x20
000040  4b09              LDR      r3,|L10.104|
000042  221e              MOVS     r2,#0x1e
000044  a901              ADD      r1,sp,#4
000046  9000              STR      r0,[sp,#0]
000048  4809              LDR      r0,|L10.112|
00004a  f7fffffe          BL       os_task_init
00004e  b2c6              UXTB     r6,r0
;;;387    	os_start(300);
000050  f44f7096          MOV      r0,#0x12c
000054  f7fffffe          BL       os_start
;;;388      //  while (1)
;;;389      //  {
;;;390    
;;;391      //  /* USER CODE END WHILE */
;;;392    
;;;393      //  /* USER CODE BEGIN 3 */
;;;394    
;;;395      //  }
;;;396      //  /* USER CODE END 3 */
;;;397    
;;;398      //}
;;;399     }
000058  2000              MOVS     r0,#0
00005a  bd7c              POP      {r2-r6,pc}
;;;400    /**
                          ENDP

                  |L10.92|
                          DCD      0x000186a0
                  |L10.96|
                          DCD      0x000f4240
                  |L10.100|
                          DCD      stack1
                  |L10.104|
                          DCD      stack2
                  |L10.108|
                          DCD      blinky2
                  |L10.112|
                          DCD      blinky

                          AREA ||i.os_init||, CODE, READONLY, ALIGN=2

                  os_init PROC
;;;152    
;;;153    bool os_init(void) {
000000  b510              PUSH     {r4,lr}
;;;154      if (m_state != OS_STATE_DEFAULT)
000002  4809              LDR      r0,|L11.40|
000004  7800              LDRB     r0,[r0,#0]  ; m_state
000006  2801              CMP      r0,#1
000008  d001              BEQ      |L11.14|
;;;155        return false;
00000a  2000              MOVS     r0,#0
                  |L11.12|
;;;156    
;;;157      memset( &m_task_table, 0, sizeof(m_task_table));
;;;158      m_state = OS_STATE_INITIALIZED;
;;;159    
;;;160      m_task_table.size = 0;
;;;161    
;;;162      return true;
;;;163    }
00000c  bd10              POP      {r4,pc}
                  |L11.14|
00000e  21cc              MOVS     r1,#0xcc              ;157
000010  4806              LDR      r0,|L11.44|
000012  f7fffffe          BL       __aeabi_memclr4
000016  2002              MOVS     r0,#2                 ;158
000018  4903              LDR      r1,|L11.40|
00001a  7008              STRB     r0,[r1,#0]            ;158
00001c  2000              MOVS     r0,#0                 ;160
00001e  4903              LDR      r1,|L11.44|
000020  f8a100ca          STRH     r0,[r1,#0xca]         ;160
000024  2001              MOVS     r0,#1                 ;162
000026  e7f1              B        |L11.12|
;;;164    
                          ENDP

                  |L11.40|
                          DCD      m_state
                  |L11.44|
                          DCD      m_task_table

                          AREA ||i.os_scheduler||, CODE, READONLY, ALIGN=2

                  os_scheduler PROC
;;;232    
;;;233    bool os_scheduler(){
000000  b510              PUSH     {r4,lr}
;;;234    	bool is_preempted;
;;;235    	is_preempted = false;
000002  2400              MOVS     r4,#0
;;;236    	uint32_t next_task = get_next_task();
000004  f7fffffe          BL       get_next_task
000008  4603              MOV      r3,r0
;;;237    	os_curr_task = &m_task_table.tasks[m_task_table.current_task];
00000a  481e              LDR      r0,|L12.132|
00000c  f89000c8          LDRB     r0,[r0,#0xc8]  ; m_task_table
000010  eb000080          ADD      r0,r0,r0,LSL #2
000014  491b              LDR      r1,|L12.132|
000016  eb010080          ADD      r0,r1,r0,LSL #2
00001a  491b              LDR      r1,|L12.136|
00001c  6008              STR      r0,[r1,#0]  ; os_curr_task
;;;238    	os_next_task = &m_task_table.tasks[next_task];
00001e  eb030083          ADD      r0,r3,r3,LSL #2
000022  4918              LDR      r1,|L12.132|
000024  eb010080          ADD      r0,r1,r0,LSL #2
000028  4918              LDR      r1,|L12.140|
00002a  6008              STR      r0,[r1,#0]  ; os_next_task
;;;239    				
;;;240      // os_curr_task -> status = OS_TASK_STATUS_IDLE;
;;;241    
;;;242    		if (os_curr_task->status == OS_TASK_STATUS_SUSPENDED) {
00002c  4816              LDR      r0,|L12.136|
00002e  6800              LDR      r0,[r0,#0]  ; os_curr_task
000030  7c00              LDRB     r0,[r0,#0x10]
000032  2803              CMP      r0,#3
000034  d10c              BNE      |L12.80|
;;;243    			is_preempted = true;
000036  2401              MOVS     r4,#1
;;;244    			os_next_task->status = OS_TASK_STATUS_ACTIVE;
000038  2002              MOVS     r0,#2
00003a  6809              LDR      r1,[r1,#0]  ; os_next_task
00003c  7408              STRB     r0,[r1,#0x10]
;;;245    			os_priority = os_next_task->priority;
00003e  4813              LDR      r0,|L12.140|
000040  6800              LDR      r0,[r0,#0]  ; os_next_task
000042  7c40              LDRB     r0,[r0,#0x11]
000044  4912              LDR      r1,|L12.144|
000046  6008              STR      r0,[r1,#0]  ; os_priority
;;;246    			m_task_table.current_task = next_task;
000048  490e              LDR      r1,|L12.132|
00004a  f88130c8          STRB     r3,[r1,#0xc8]
00004e  e016              B        |L12.126|
                  |L12.80|
;;;247    		}
;;;248    		else {
;;;249    			os_priority--;
000050  480f              LDR      r0,|L12.144|
000052  6800              LDR      r0,[r0,#0]  ; os_priority
000054  1e40              SUBS     r0,r0,#1
000056  490e              LDR      r1,|L12.144|
000058  6008              STR      r0,[r1,#0]  ; os_priority
;;;250    			if(os_priority <= 0){
00005a  4608              MOV      r0,r1
00005c  6800              LDR      r0,[r0,#0]  ; os_priority
00005e  b968              CBNZ     r0,|L12.124|
;;;251    				is_preempted = true;
000060  2401              MOVS     r4,#1
;;;252    				os_next_task -> status = OS_TASK_STATUS_ACTIVE;
000062  2002              MOVS     r0,#2
000064  4909              LDR      r1,|L12.140|
000066  6809              LDR      r1,[r1,#0]  ; os_next_task
000068  7408              STRB     r0,[r1,#0x10]
;;;253    				os_priority = os_next_task->priority;
00006a  4808              LDR      r0,|L12.140|
00006c  6800              LDR      r0,[r0,#0]  ; os_next_task
00006e  7c40              LDRB     r0,[r0,#0x11]
000070  4907              LDR      r1,|L12.144|
000072  6008              STR      r0,[r1,#0]  ; os_priority
;;;254    				m_task_table.current_task = next_task;
000074  4903              LDR      r1,|L12.132|
000076  f88130c8          STRB     r3,[r1,#0xc8]
00007a  e000              B        |L12.126|
                  |L12.124|
;;;255    			}
;;;256    			else{
;;;257    				is_preempted = false;
00007c  2400              MOVS     r4,#0
                  |L12.126|
;;;258    			}
;;;259    		}
;;;260    	
;;;261      /* Select next task: */
;;;262      /*
;;;263    	m_task_table.current_task++;
;;;264      if (m_task_table.current_task >= m_task_table.size)
;;;265        m_task_table.current_task = 0;
;;;266    
;;;267    	*/
;;;268      
;;;269    	return is_preempted;
00007e  4620              MOV      r0,r4
;;;270    }
000080  bd10              POP      {r4,pc}
;;;271    void SysTick_Handler(void) {
                          ENDP

000082  0000              DCW      0x0000
                  |L12.132|
                          DCD      m_task_table
                  |L12.136|
                          DCD      os_curr_task
                  |L12.140|
                          DCD      os_next_task
                  |L12.144|
                          DCD      os_priority

                          AREA ||i.os_start||, CODE, READONLY, ALIGN=2

                  os_start PROC
;;;199    	
;;;200    bool os_start(uint32_t systick_ticks) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;201      if (m_state != OS_STATE_TASKS_INITIALIZED)
000004  4827              LDR      r0,|L13.164|
000006  7800              LDRB     r0,[r0,#0]  ; m_state
000008  2803              CMP      r0,#3
00000a  d001              BEQ      |L13.16|
;;;202        return false;
00000c  2000              MOVS     r0,#0
                  |L13.14|
;;;203    
;;;204      NVIC_SetPriority(SysTick_IRQn, 0x00); /* Highest possible priority */
;;;205    
;;;206      /* Start the SysTick timer: */
;;;207      uint32_t ret_val = SysTick_Config(systick_ticks);
;;;208      if (ret_val != 0)
;;;209    	{
;;;210        return false;
;;;211    	}
;;;212      /* Start the first task: */
;;;213      os_curr_task = &m_task_table.tasks[m_task_table.current_task];
;;;214      m_state = OS_STATE_STARTED;
;;;215    
;;;216      __set_PSP(os_curr_task -> sp + 64); /* Set PSP to the top of task's stack */
;;;217      __set_CONTROL(0x03); /* Switch to Unprivilleged Thread Mode with PSP */
;;;218      __ISB(); /* Execute ISB after changing CONTORL (recommended) */
;;;219    	os_priority = os_curr_task->priority; 
;;;220    	_load_initial_state();
;;;221    }
00000e  bd70              POP      {r4-r6,pc}
                  |L13.16|
000010  2100              MOVS     r1,#0                 ;204
000012  1e48              SUBS     r0,r1,#1              ;204
000014  f7fffffe          BL       NVIC_SetPriority
000018  4625              MOV      r5,r4                 ;207
00001a  1e68              SUBS     r0,r5,#1              ;207
00001c  f1b07f80          CMP      r0,#0x1000000         ;207
000020  d301              BCC      |L13.38|
000022  2001              MOVS     r0,#1                 ;207
000024  e00f              B        |L13.70|
                  |L13.38|
000026  1e68              SUBS     r0,r5,#1              ;207
000028  f04f21e0          MOV      r1,#0xe000e000        ;207
00002c  6148              STR      r0,[r1,#0x14]         ;207
00002e  210f              MOVS     r1,#0xf               ;207
000030  f04f30ff          MOV      r0,#0xffffffff        ;207
000034  f7fffffe          BL       NVIC_SetPriority
000038  2000              MOVS     r0,#0                 ;207
00003a  f04f21e0          MOV      r1,#0xe000e000        ;207
00003e  6188              STR      r0,[r1,#0x18]         ;207
000040  2007              MOVS     r0,#7                 ;207
000042  6108              STR      r0,[r1,#0x10]         ;207
000044  2000              MOVS     r0,#0                 ;207
                  |L13.70|
000046  4606              MOV      r6,r0                 ;207
000048  b10e              CBZ      r6,|L13.78|
00004a  2000              MOVS     r0,#0                 ;210
00004c  e7df              B        |L13.14|
                  |L13.78|
00004e  4816              LDR      r0,|L13.168|
000050  f89000c8          LDRB     r0,[r0,#0xc8]         ;213  ; m_task_table
000054  eb000080          ADD      r0,r0,r0,LSL #2       ;213
000058  4913              LDR      r1,|L13.168|
00005a  eb010080          ADD      r0,r1,r0,LSL #2       ;213
00005e  4913              LDR      r1,|L13.172|
000060  6008              STR      r0,[r1,#0]            ;213  ; os_curr_task
000062  2004              MOVS     r0,#4                 ;214
000064  490f              LDR      r1,|L13.164|
000066  7008              STRB     r0,[r1,#0]            ;214
000068  4910              LDR      r1,|L13.172|
00006a  6809              LDR      r1,[r1,#0]            ;216  ; os_curr_task
00006c  6809              LDR      r1,[r1,#0]            ;216
00006e  f1010040          ADD      r0,r1,#0x40           ;216
000072  f3808809          MSR      PSP,r0                ;216
000076  bf00              NOP                            ;216
000078  2003              MOVS     r0,#3                 ;217
00007a  f3808814          MSR      CONTROL,r0            ;217
00007e  bf00              NOP                            ;217
000080  bf00              NOP                            ;218
000082  bf00              NOP                            ;218
000084  bf00              NOP                            ;218
000086  f3bf8f6f          ISB                            ;218
00008a  bf00              NOP                            ;218
00008c  bf00              NOP                            ;218
00008e  bf00              NOP                            ;218
000090  4806              LDR      r0,|L13.172|
000092  6800              LDR      r0,[r0,#0]            ;219  ; os_curr_task
000094  7c40              LDRB     r0,[r0,#0x11]         ;219
000096  4906              LDR      r1,|L13.176|
000098  6008              STR      r0,[r1,#0]            ;219  ; os_priority
00009a  f7fffffe          BL       _load_initial_state
00009e  bf00              NOP      
0000a0  e7b5              B        |L13.14|
;;;222    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L13.164|
                          DCD      m_state
                  |L13.168|
                          DCD      m_task_table
                  |L13.172|
                          DCD      os_curr_task
                  |L13.176|
                          DCD      os_priority

                          AREA ||i.os_task_init||, CODE, READONLY, ALIGN=2

                  os_task_init PROC
;;;174    
;;;175    int os_task_init(void( * handler)(void * p_params), void * p_task_params,
000000  b5f0              PUSH     {r4-r7,lr}
;;;176      uint8_t p_task_priority, uint32_t * p_stack, size_t stack_size) {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  9c05              LDR      r4,[sp,#0x14]
;;;177    
;;;178      if (m_task_table.size >= OS_CONFIG_MAX_TASKS - 1)
000008  481a              LDR      r0,|L14.116|
00000a  f8b000ca          LDRH     r0,[r0,#0xca]  ; m_task_table
00000e  2809              CMP      r0,#9
000010  db01              BLT      |L14.22|
;;;179        return false;
000012  2000              MOVS     r0,#0
                  |L14.20|
;;;180      struct os_task * p_task = &m_task_table.tasks[m_task_table.size];
;;;181      p_task->handler = handler;
;;;182    	p_task->p_params = p_task_params;
;;;183      p_task->priority = p_task_priority;
;;;184    	/* Initialize the task structure and set SP to the top of the stack
;;;185         minus 16 words (64 bytes) to leave space for storing 16 registers: */
;;;186      p_task->sp = (uint32_t) &p_stack[stack_size - 16];
;;;187      p_task->status = OS_TASK_STATUS_IDLE;
;;;188    
;;;189      //Save init. values of registers which will be restored on exc. return:   
;;;190      p_stack[stack_size - 1] = 0x01000000; // - XPSR: Default value (0x01000000)
;;;191      p_stack[stack_size - 2] = (uint32_t) handler; // - PC: Point to the handler function
;;;192      p_stack[stack_size - 3] = (uint32_t) task_finished; //- LR: Point to thread return handler
;;;193      p_stack[stack_size - 8] = (uint32_t) p_task_params; //- R0: Point to the handler function's parameter
;;;194    
;;;195      m_state = OS_STATE_TASKS_INITIALIZED;
;;;196     
;;;197      return  m_task_table.size++;
;;;198    }
000014  bdf0              POP      {r4-r7,pc}
                  |L14.22|
000016  4817              LDR      r0,|L14.116|
000018  f8b000ca          LDRH     r0,[r0,#0xca]         ;180  ; m_task_table
00001c  eb000080          ADD      r0,r0,r0,LSL #2       ;180
000020  4f14              LDR      r7,|L14.116|
000022  eb070180          ADD      r1,r7,r0,LSL #2       ;180
000026  604d              STR      r5,[r1,#4]            ;181
000028  608e              STR      r6,[r1,#8]            ;182
00002a  744a              STRB     r2,[r1,#0x11]         ;183
00002c  f1a40010          SUB      r0,r4,#0x10           ;186
000030  eb030080          ADD      r0,r3,r0,LSL #2       ;186
000034  6008              STR      r0,[r1,#0]            ;186
000036  2001              MOVS     r0,#1                 ;187
000038  7408              STRB     r0,[r1,#0x10]         ;187
00003a  0607              LSLS     r7,r0,#24             ;190
00003c  1e60              SUBS     r0,r4,#1              ;190
00003e  f8437020          STR      r7,[r3,r0,LSL #2]     ;190
000042  1ea0              SUBS     r0,r4,#2              ;191
000044  f8435020          STR      r5,[r3,r0,LSL #2]     ;191
000048  4f0b              LDR      r7,|L14.120|
00004a  1ee0              SUBS     r0,r4,#3              ;192
00004c  f8437020          STR      r7,[r3,r0,LSL #2]     ;192
000050  1f40              SUBS     r0,r0,#5              ;193
000052  f8436020          STR      r6,[r3,r0,LSL #2]     ;193
000056  2003              MOVS     r0,#3                 ;195
000058  4f08              LDR      r7,|L14.124|
00005a  7038              STRB     r0,[r7,#0]            ;195
00005c  4805              LDR      r0,|L14.116|
00005e  f8b000ca          LDRH     r0,[r0,#0xca]         ;197  ; m_task_table
000062  4f04              LDR      r7,|L14.116|
000064  f8b770ca          LDRH     r7,[r7,#0xca]         ;197  ; m_task_table
000068  1c7f              ADDS     r7,r7,#1              ;197
00006a  f8dfc008          LDR      r12,|L14.116|
00006e  f8ac70ca          STRH     r7,[r12,#0xca]        ;197
000072  e7cf              B        |L14.20|
;;;199    	
                          ENDP

                  |L14.116|
                          DCD      m_task_table
                  |L14.120|
                          DCD      task_finished
                  |L14.124|
                          DCD      m_state

                          AREA ||i.os_task_resume||, CODE, READONLY, ALIGN=2

                  os_task_resume PROC
;;;169    
;;;170    void os_task_resume(uint8_t task_id) {
000000  2102              MOVS     r1,#2
;;;171    	m_task_table.tasks[task_id].status = OS_TASK_STATUS_ACTIVE;
000002  eb000280          ADD      r2,r0,r0,LSL #2
000006  4b02              LDR      r3,|L15.16|
000008  eb030282          ADD      r2,r3,r2,LSL #2
00000c  7411              STRB     r1,[r2,#0x10]
;;;172    }
00000e  4770              BX       lr
;;;173    	
                          ENDP

                  |L15.16|
                          DCD      m_task_table

                          AREA ||i.os_task_suspend||, CODE, READONLY, ALIGN=2

                  os_task_suspend PROC
;;;165    
;;;166    void os_task_suspend(uint8_t task_id) {
000000  2103              MOVS     r1,#3
;;;167    	m_task_table.tasks[task_id].status = OS_TASK_STATUS_SUSPENDED;
000002  eb000280          ADD      r2,r0,r0,LSL #2
000006  4b02              LDR      r3,|L16.16|
000008  eb030282          ADD      r2,r3,r2,LSL #2
00000c  7411              STRB     r1,[r2,#0x10]
;;;168    }
00000e  4770              BX       lr
;;;169    
                          ENDP

                  |L16.16|
                          DCD      m_task_table

                          AREA ||i.task_finished||, CODE, READONLY, ALIGN=1

                  task_finished PROC
;;;143    
;;;144    static void task_finished(void) {
000000  b508              PUSH     {r3,lr}
;;;145      /* This function is called when some task handler returns. */
;;;146    
;;;147      volatile uint8_t i = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;148      while (1) {
000006  e004              B        |L17.18|
                  |L17.8|
;;;149        i++;
000008  f89d0000          LDRB     r0,[sp,#0]
00000c  1c40              ADDS     r0,r0,#1
00000e  b2c0              UXTB     r0,r0
000010  9000              STR      r0,[sp,#0]
                  |L17.18|
000012  e7f9              B        |L17.8|
;;;150      }
;;;151    }
;;;152    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  GPIO_InitStruct
                          %        16
                  GPIO_InitStruct2
                          %        16
                  stack1
                          %        128
                  stack2
                          %        128
                  m_task_table
                          %        204

                          AREA ||.data||, DATA, ALIGN=2

                  os_curr_task
                          DCD      0x00000000
                  os_next_task
                          DCD      0x00000000
                  mpsp
                          DCD      0x00000000
                  handler
                          DCD      0x00000000
                  params
                          DCD      0x00000000
                  xPSR
                          DCD      0x00000000
                  thread_return
                          DCD      0x00000000
                  os_priority
                          DCD      0x00000000
                  m_state
000020  01                DCB      0x01

;*** Start embedded assembler ***

#line 1 "../Src/main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_os_init____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___6_main_c_os_init____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_os_init____REVSH|
#line 402
|__asm___6_main_c_os_init____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_os_init____RRX|
#line 587
|__asm___6_main_c_os_init____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
